<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Tower Defense (Kingdom Rush-like) ‚Äî Single File</title>
  <style>
    :root{
      --panel:#121a23cc;
      --panel2:#0f1620ee;
      --stroke:#2a3a4a;
      --text:#e8f1ff;
      --muted:#a9b7c6;
      --good:#62d26f;
      --bad:#ff5a6a;
      --gold:#ffcc4d;
      --accent:#55b6ff;
      --shadow: 0 12px 28px rgba(0,0,0,.45);
      --radius: 14px;
      --btn:#1a2633;
      --btn2:#243446;
      --btnDis:#1a2633aa;
    }
    *{ box-sizing:border-box; user-select:none; }
    html,body{ height:100%; margin:0; background:radial-gradient(1200px 700px at 50% 35%, #0f1620 0%, #070a0e 70%, #05070a 100%); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow:hidden;}
    #wrap{ position:relative; width:100%; height:100%; }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; background:transparent; }

    /* HUD */
    #hud{
      position:absolute; left:12px; right:12px; top:12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events:none;
    }
    .hud-left,.hud-right{ display:flex; gap:10px; align-items:center; pointer-events:auto; flex-wrap:wrap;}
    .chip{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border:1px solid var(--stroke);
      background:linear-gradient(180deg, var(--panel), rgba(12,18,26,.55));
      border-radius:999px; box-shadow:var(--shadow); backdrop-filter: blur(6px);
      font-weight:800;
    }
    .chip small{ color:var(--muted); font-weight:600; }
    .chip .dot{ width:10px; height:10px; border-radius:50%; background:var(--accent); box-shadow:0 0 10px rgba(85,182,255,.35); }
    .chip .dot.gold{ background:var(--gold); box-shadow:0 0 10px rgba(255,204,77,.35); }
    .chip .dot.life{ background:var(--bad); box-shadow:0 0 10px rgba(255,90,106,.35); }
    .chip .dot.wave{ background:#b06cff; box-shadow:0 0 10px rgba(176,108,255,.35); }

    .btnbar{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none; border:none; cursor:pointer;
      padding:10px 12px; border-radius:999px;
      color:var(--text); font-weight:900; letter-spacing:.2px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid #2b3e52;
      box-shadow:var(--shadow);
      transition: transform .05s ease, filter .15s ease;
      white-space:nowrap;
    }
    button:hover{ filter:brightness(1.08); }
    button:active{ transform: translateY(1px); }
    button:disabled{
      cursor:not-allowed; background:linear-gradient(180deg, var(--btnDis), var(--btnDis));
      color:rgba(232,241,255,.55); border-color:#223244;
      box-shadow:none; filter:saturate(.6);
    }
    .btn-accent{ border-color:#2c5875; background:linear-gradient(180deg, #2a516d, #1a2b3c); }
    .btn-bad{ border-color:#7a2d39; background:linear-gradient(180deg, #6a2a35, #1a1116); }
    .btn-good{ border-color:#2b6e3a; background:linear-gradient(180deg, #2f6d3f, #18251d); }
    .btn-ghost{ background:linear-gradient(180deg, rgba(18,26,35,.75), rgba(12,18,26,.55)); border-color:var(--stroke); }
    .btn-skill{ border-color:#6a3a2a; background:linear-gradient(180deg, rgba(120,70,40,.95), rgba(30,18,14,.95)); }
    .btn-skill2{ border-color:#2b6e3a; background:linear-gradient(180deg, rgba(60,120,70,.95), rgba(18,30,20,.95)); }
    .btn-hero{ border-color:#4b3f8a; background:linear-gradient(180deg, rgba(105,92,210,.95), rgba(24,20,44,.95)); }
    .btn-hero2{ border-color:#8a3f7a; background:linear-gradient(180deg, rgba(210,92,175,.95), rgba(44,20,34,.95)); }

    /* Panels */
    .panel{
      position:absolute; min-width:240px;
      background:linear-gradient(180deg, var(--panel2), rgba(10,14,20,.92));
      border:1px solid #2a3a4a;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:12px;
      display:none;
      pointer-events:auto;
      transform-origin: top left;
    }
    .panel h3{ margin:0 0 6px; font-size:14px; letter-spacing:.2px; }
    .panel .sub{ color:var(--muted); font-size:12px; margin-bottom:10px; }
    .grid4{ display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; }
    .card{
      border:1px solid #2a3a4a; border-radius:12px;
      padding:10px; background:linear-gradient(180deg, rgba(20,30,42,.7), rgba(14,20,28,.55));
      display:flex; flex-direction:column; gap:8px;
    }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .tag{ font-size:11px; color:var(--muted); font-weight:700; letter-spacing:.25px; }
    .price{ font-weight:900; color:var(--gold); }
    .stats{ font-size:12px; color:var(--muted); display:grid; grid-template-columns:1fr 1fr; gap:6px 12px; }
    .stats b{ color:var(--text); }
    .panel .panelbtns{ display:flex; gap:10px; margin-top:10px; }
    .panel .panelbtns button{ flex:1; border-radius:12px; padding:10px 12px; }

    /* Overlay */
    #overlay{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      background: radial-gradient(900px 500px at 50% 40%, rgba(20,30,42,.70) 0%, rgba(5,7,10,.85) 70%);
      backdrop-filter: blur(6px);
      pointer-events:auto;
    }
    #overlay .box{
      width:min(560px, calc(100% - 40px));
      background: linear-gradient(180deg, rgba(18,26,35,.95), rgba(8,10,14,.95));
      border:1px solid #2a3a4a;
      border-radius: 18px;
      padding: 18px;
      box-shadow: var(--shadow);
      text-align:center;
    }
    #overlay h1{ margin:6px 0 10px; font-size:28px; }
    #overlay p{ margin:0 0 14px; color:var(--muted); line-height:1.5; }
    #overlay .box .actions{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    #overlay .box .actions button{ min-width:140px; }

    /* Tooltip */
    #tip{
      position:absolute; z-index:20;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid #2a3a4a;
      background:rgba(10,14,20,.92);
      color:var(--text);
      font-size:12px;
      display:none;
      pointer-events:none;
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      max-width:320px;
      white-space:pre-line;
    }
    #tip .t{ font-weight:900; margin-bottom:3px; }
    #tip .d{ color:var(--muted); line-height:1.35; }

    /* Bottom hint */
    #hint{
      position:absolute; left:12px; bottom:12px;
      padding:10px 12px; border-radius:999px;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(18,26,35,.70), rgba(12,18,26,.45));
      color:var(--muted);
      font-size:12px;
      box-shadow: var(--shadow);
      pointer-events:none;
      max-width: calc(100% - 24px);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    #hint b{ color:var(--text); }

    @media (max-width:720px){
      #hud{ left:10px; right:10px; top:10px; gap:8px; }
      button{ padding:9px 10px; font-size:12px; }
      .chip{ padding:9px 10px; font-size:12px; }
      .panel{ min-width:220px; }
      #hint{ font-size:11px; }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="hud">
    <div class="hud-left">
      <div class="chip" id="chipGold"><span class="dot gold"></span><span>Gold: <span id="uiGold">0</span></span></div>
      <div class="chip" id="chipLives"><span class="dot life"></span><span>Lives: <span id="uiLives">0</span></span></div>
      <div class="chip" id="chipWave"><span class="dot wave"></span><span>Wave: <span id="uiWave">0</span>/<span id="uiWaveMax">0</span> <small id="uiWaveState"></small></span></div>
    </div>
    <div class="hud-right btnbar">
      <button id="btnRain" class="btn-skill"
        data-tip-title="‚òÑÔ∏è Rain of Fire (R)"
        data-tip-desc="G·ªçi m∆∞a thi√™n th·∫°ch g√¢y s√°t th∆∞∆°ng AoE l·ªõn (tr√∫ng c·∫£ bay).\nB·∫•m n√∫t r·ªìi click map ƒë·ªÉ th·∫£.\nCooldown: 32s.">‚òÑÔ∏è Rain</button>
      <button id="btnRein" class="btn-skill2"
        data-tip-title="ü™ñ Call Reinforcements (E)"
        data-tip-desc="G·ªçi 2 l√≠nh vi·ªán tr·ª£ (t·∫°m th·ªùi) ƒë·ªÉ ch·∫∑n ƒë∆∞·ªùng.\nB·∫•m n√∫t r·ªìi click map ƒë·ªÉ ƒë·∫∑t.\nCooldown: 18s.">ü™ñ Reinforce</button>

      <button id="btnHero" class="btn-hero"
        data-tip-title="ü¶∏ Hero"
        data-tip-desc="Click hero tr√™n map ƒë·ªÉ ch·ªçn.\nKhi hero ƒëang ch·ªçn: click map ƒë·ªÉ di chuy·ªÉn.\nHotkey: H (ch·ªçn/b·ªè ch·ªçn).">ü¶∏ Hero</button>
      <button id="btnSmash" class="btn-hero2"
        data-tip-title="üí• Hero Smash (Q)"
        data-tip-desc="K·ªπ nƒÉng c·ªßa hero: n·ªï AoE + cho√°ng nh·∫π (ch·ªâ ground).\nCast ngay t·∫°i v·ªã tr√≠ hero.\nCooldown: 18s.">üí• Smash</button>

      <button id="btnStart" class="btn-good" data-tip-title="Start Wave (S)" data-tip-desc="B·∫Øt ƒë·∫ßu wave ti·∫øp theo. G·ªçi s·ªõm ƒë·ªÉ nh·∫≠n bonus v√†ng theo th·ªùi gian c√≤n l·∫°i.">Start Wave</button>
      <button id="btnPause" class="btn-ghost" data-tip-title="Pause (Space)" data-tip-desc="T·∫°m d·ª´ng / ti·∫øp t·ª•c game.">Pause</button>
      <button id="btnSpeed" class="btn-accent" data-tip-title="Speed (1/2)" data-tip-desc="Chuy·ªÉn t·ªëc ƒë·ªô x1/x2.">x1</button>
    </div>
  </div>

  <div id="buildPanel" class="panel">
    <h3>Build Tower</h3>
    <div class="sub">Ch·ªçn 1 th√°p ƒë·ªÉ x√¢y tr√™n pad n√†y.</div>
    <div class="grid4" id="buildGrid"></div>
  </div>

  <div id="towerPanel" class="panel">
    <h3 id="tpTitle">Tower</h3>
    <div class="sub" id="tpSub">Level 1</div>
    <div class="stats" id="tpStats"></div>
    <div class="panelbtns">
      <button id="btnUpgrade" class="btn-good">Upgrade</button>
      <button id="btnSell" class="btn-bad">Sell</button>
    </div>
    <div class="panelbtns" id="tpExtra" style="display:none; margin-top:10px;">
      <button id="btnRally" class="btn-accent">Rally</button>
      <button id="btnCancelRally" class="btn-ghost">Cancel</button>
    </div>
  </div>

  <div id="heroPanel" class="panel">
    <h3 id="hpTitle">ü¶∏ Hero</h3>
    <div class="sub" id="hpSub">Click map ƒë·ªÉ di chuy·ªÉn</div>
    <div class="stats" id="hpStats"></div>
    <div class="panelbtns">
      <button id="btnHpSmash" class="btn-hero2">Smash</button>
      <button id="btnHpClose" class="btn-ghost">Close</button>
    </div>
  </div>

  <div id="overlay">
    <div class="box">
      <h1 id="ovTitle">Victory!</h1>
      <p id="ovDesc">...</p>
      <div class="actions">
        <button id="btnRestart" class="btn-good">Restart</button>
        <button id="btnCloseOv" class="btn-ghost">Close</button>
      </div>
    </div>
  </div>

  <div id="tip"></div>
  <div id="hint">
    Click pad ƒë·ªÉ x√¢y ¬∑ Click th√°p ƒë·ªÉ n√¢ng/b√°n ¬∑ <b>Barracks</b>: Rally r·ªìi click map ¬∑ <b>Skills</b>: <b>R</b> Rain, <b>E</b> Reinforce ¬∑ <b>Hero</b>: click hero ƒë·ªÉ ch·ªçn, click map ƒë·ªÉ ƒëi, <b>Q</b> Smash ¬∑ Hotkeys: <b>S</b> start, <b>Space</b> pause, <b>1/2</b> speed
  </div>
</div>

<script>
(() => {
  "use strict";

  /* =========================
     Helpers
  ========================= */
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const dist2 = (ax, ay, bx, by) => { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; };
  const now = () => performance.now();
  const fmt = (n) => Math.floor(n).toString();

  function rnd(a=1){ return Math.random()*a; }
  function rndi(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

  /* =========================
     Data
  ========================= */
  const MAP = {
    w: 960, h: 540,
    start: { x: 70, y: 120 },
    end:   { x: 900, y: 420 },
    waypoints: [
      {x: 70,  y: 120},
      {x: 210, y: 120},
      {x: 250, y: 210},
      {x: 140, y: 260},
      {x: 140, y: 380},
      {x: 320, y: 410},
      {x: 480, y: 320},
      {x: 620, y: 300},
      {x: 720, y: 360},
      {x: 820, y: 420},
      {x: 900, y: 420},
    ],
    pads: [
      {id:0, x: 250, y: 80},
      {id:1, x: 330, y: 170},
      {id:2, x: 90,  y: 220},
      {id:3, x: 220, y: 300},
      {id:4, x: 260, y: 470},
      {id:5, x: 450, y: 420},
      {id:6, x: 520, y: 250},
      {id:7, x: 670, y: 260},
      {id:8, x: 790, y: 330},
      {id:9, x: 860, y: 500},
    ],
    padR: 18,
    pathWidth: 54
  };

  const SELL_REFUND = 0.70;

  const TOWER_DEFS = {
    archer: {
      key:"archer", name:"Archer Tower", dmgType:"physical",
      icon:"üèπ",
      levels: [
        { build: 70,  dmg: 10, range: 155, rate: 0.52, projSpd: 450, crit:0.07 },
        { up:   85,  dmg: 17, range: 170, rate: 0.48, projSpd: 480, crit:0.09 },
        { up:  120,  dmg: 25, range: 185, rate: 0.44, projSpd: 510, crit:0.11 },
      ],
      desc:"B·∫Øn nhanh, ƒë√°nh ƒë∆∞·ª£c c·∫£ bay. S√°t th∆∞∆°ng v·∫≠t l√Ω."
    },
    mage: {
      key:"mage", name:"Mage Tower", dmgType:"magic",
      icon:"üîÆ",
      levels: [
        { build: 85,  dmg: 16, range: 145, rate: 0.78, projSpd: 400, pierceArmor: true },
        { up:  110,  dmg: 25, range: 160, rate: 0.74, projSpd: 420, pierceArmor: true },
        { up:  155,  dmg: 36, range: 175, rate: 0.69, projSpd: 440, pierceArmor: true },
      ],
      desc:"S√°t th∆∞∆°ng ph√©p, xuy√™n gi√°p t·ªët."
    },
    barracks: {
      key:"barracks", name:"Barracks", dmgType:"melee",
      icon:"üõ°Ô∏è",
      levels: [
        { build: 90,  soldiers:2, sHp: 85,  sDmg: 12, sRate: 0.95, sSpd: 130, blockR: 100, respawn: 5.5 },
        { up:  120,  soldiers:3, sHp: 115, sDmg: 16, sRate: 0.92, sSpd: 135, blockR: 110, respawn: 5.0 },
        { up:  160,  soldiers:3, sHp: 150, sDmg: 22, sRate: 0.88, sSpd: 140, blockR: 120, respawn: 4.6 },
      ],
      desc:"ƒê·∫ª l√≠nh ch·∫∑n ƒë∆∞·ªùng, ƒë√°nh c·∫≠n chi·∫øn (kh√¥ng ch·∫∑n ƒë∆∞·ª£c bay)."
    },
    artillery: {
      key:"artillery", name:"Artillery", dmgType:"physical",
      icon:"üí£",
      levels: [
        { build: 100, dmg: 32, range: 170, rate: 1.45, blastR: 58, projSpd: 320, slowMul:0.72, slowDur:0.9 },
        { up:   135, dmg: 46, range: 185, rate: 1.35, blastR: 65, projSpd: 340, slowMul:0.70, slowDur:1.0 },
        { up:   180, dmg: 64, range: 200, rate: 1.25, blastR: 75, projSpd: 360, slowMul:0.68, slowDur:1.1 },
      ],
      desc:"N·ªï AoE m·∫°nh (ch·ªâ b·∫Øn b·ªô). C√≥ l√†m ch·∫≠m ng·∫Øn."
    },
  };

  const ENEMY_DEFS = {
    goblin: { name:"Goblin",  hp: 55,  spd: 84,  armor:0.04, mres:0.00, reward: 7,  size:12,  color:"#80ff8a", flying:false, dmgToLives:1, meleeDmg:9,  meleeRate:1.15 },
    orc:    { name:"Orc",     hp: 125, spd: 60,  armor:0.08, mres:0.04, reward: 10, size:14,  color:"#79c86a", flying:false, dmgToLives:1, meleeDmg:13, meleeRate:1.25 },
    armored:{ name:"Armored", hp: 150, spd: 54,  armor:0.38, mres:0.05, reward: 14, size:15,  color:"#c6d1df", flying:false, dmgToLives:1, meleeDmg:15, meleeRate:1.30 },
    shaman: { name:"Shaman",  hp: 105, spd: 56,  armor:0.08, mres:0.25, reward: 16, size:13,  color:"#7fe7ff", flying:false, dmgToLives:1, meleeDmg:11, meleeRate:1.35,
              healR: 85, healPS: 5.0 },
    runner: { name:"Runner",  hp: 70,  spd: 110, armor:0.04, mres:0.00, reward: 9,  size:12,  color:"#ffd166", flying:false, dmgToLives:1, meleeDmg:9,  meleeRate:1.10 },
    flying: { name:"Flying",  hp: 85,  spd: 92,  armor:0.00, mres:0.12, reward: 12, size:12,  color:"#b388ff", flying:true,  dmgToLives:1, meleeDmg:0,  meleeRate:0 },
    tank:   { name:"Tank",    hp: 235, spd: 38,  armor:0.18, mres:0.10, reward: 22, size:17,  color:"#ff8fab", flying:false, dmgToLives:2, meleeDmg:18, meleeRate:1.40 },
    boss:   { name:"Boss",    hp: 1150,spd: 43,  armor:0.20, mres:0.18, reward: 150,size:22,  color:"#ff4d6d", flying:false, dmgToLives:4, meleeDmg:26, meleeRate:1.40,
              roarCD: 11.0, roarDur: 1.1, roarR: 120, spawnCD: 8.0, spawnType:"goblin", spawnCount: 3 },
  };

  const WAVES = [
    { name:"1", groups:[ {type:"goblin", count:9,  interval:0.62, delay:0.0} ]},
    { name:"2", groups:[ {type:"goblin", count:8,  interval:0.58, delay:0.0}, {type:"runner", count:5, interval:0.70, delay:1.0} ]},
    { name:"3", groups:[ {type:"orc", count:7,     interval:0.80, delay:0.5}, {type:"goblin", count:10, interval:0.58, delay:0.0} ]},
    { name:"4", groups:[ {type:"armored", count:5, interval:0.95, delay:0.5}, {type:"runner", count:7, interval:0.65, delay:0.0} ]},
    { name:"5", groups:[ {type:"orc", count:9,     interval:0.74, delay:0.2}, {type:"shaman", count:3, interval:1.25, delay:0.9} ]},
    { name:"6", groups:[ {type:"flying", count:9,  interval:0.74, delay:0.0}, {type:"goblin", count:9, interval:0.60, delay:0.9} ]},
    { name:"7", groups:[ {type:"tank", count:4,    interval:1.35, delay:0.6}, {type:"armored", count:7, interval:0.90, delay:0.2} ]},
    { name:"8", groups:[ {type:"shaman", count:4,  interval:1.15, delay:0.6}, {type:"orc", count:9, interval:0.70, delay:0.3}, {type:"runner", count:9, interval:0.60, delay:0.0} ]},
    { name:"9", groups:[ {type:"flying", count:11, interval:0.62, delay:0.0}, {type:"armored", count:9, interval:0.85, delay:0.5} ]},
    { name:"10", groups:[ {type:"tank", count:5,   interval:1.25, delay:0.7}, {type:"shaman", count:4, interval:1.10, delay:0.3} ]},
    { name:"11", groups:[ {type:"runner", count:12,interval:0.50, delay:0.0}, {type:"orc", count:10, interval:0.66, delay:0.5}, {type:"flying", count:9, interval:0.60, delay:0.4} ]},
    { name:"12 (Boss)", groups:[ {type:"armored", count:7, interval:0.78, delay:0.3}, {type:"boss", count:1, interval:0.0, delay:1.1}, {type:"tank", count:5, interval:1.15, delay:0.9} ]},
  ];

  const SKILLS = {
    rain: { key:"rain", name:"Rain of Fire", cdMax: 32, radius: 70, meteors: 7, spread: 55, damage: 90, dmgType:"magic", stun: 0.22 },
    rein: { key:"rein", name:"Call Reinforcements", cdMax: 18, duration: 14.0, units: 2, blockR: 95, hp: 95, dmg: 13, rate: 0.92, spd: 150 },
  };

  // Fun extras
  const HERO_DEF = {
    name: "Sir B√°nh M√¨",
    maxHp: 520,
    dmg: 30,
    rate: 0.55,
    spd: 185,
    aggroR: 125,
    blockR: 105,
    contactR: 18,
    respawn: 8.5,
    smash: { cdMax: 18, radius: 95, damage: 120, stun: 0.55, slowMul:0.78, slowDur: 0.8 },
  };

  const JOKES = [
    "Goblin: 'em ƒëi l·∫°c v√†o ƒë√¢y t√≠ th√¥i...'",
    "Orc: 'ai cho x√¢y nh√† gi·ªØa ƒë∆∞·ªùng v·∫≠y?!'",
    "Shaman: 'heal nh·∫π th√¥i, ƒë·ª´ng report!'",
    "Archer: 'b·∫Øn ph√°t n·ªØa l√† tr√∫ng m√†...'",
    "Mage: 'ph√©p thu·∫≠t l√† khoa h·ªçc ch∆∞a h·ªçc xong!'",
    "Artillery: 'boom... v√† h·∫øt c√¢u chuy·ªán.'",
    "Barracks: 'ƒë·ª©ng l·∫°i n√≥i chuy·ªán c√°i!'",
    "Tip: click r∆∞∆°ng ƒë·ªÉ nh·∫∑t v√†ng üòÑ",
    "Boss: 'ta ƒë·∫øn ƒë·ªÉ xin... 1 √≠t lives.'",
  ];

  /* =========================
     Audio
  ========================= */
  class SFX {
    constructor(){ this.ctx=null; this.master=null; this.enabled=true; }
    ensure(){
      if (!this.enabled) return;
      if (!this.ctx){
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = AC ? new AC() : null;
        if (this.ctx){
          this.master = this.ctx.createGain();
          this.master.gain.value = 0.20;
          this.master.connect(this.ctx.destination);
        }
      }
    }
    beep(freq=440, dur=0.06, type="sine", gain=0.35){
      if (!this.enabled) return;
      this.ensure(); if (!this.ctx) return;
      const t0 = this.ctx.currentTime;
      const osc = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.value = 0.0001;
      osc.connect(g); g.connect(this.master);
      osc.start(t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      osc.stop(t0 + dur + 0.02);
    }
    click(){ this.beep(520,0.05,"triangle",0.28); }
    build(){ this.beep(680,0.07,"square",0.22); }
    upgrade(){ this.beep(760,0.08,"triangle",0.26); }
    sell(){ this.beep(240,0.08,"sawtooth",0.20); }
    shoot(){ this.beep(860,0.03,"triangle",0.12); }
    boom(){ this.beep(160,0.10,"sawtooth",0.22); }
    hurt(){ this.beep(320,0.05,"square",0.12); }
    wave(){ this.beep(540,0.10,"triangle",0.22); }
    win(){ this.beep(660,0.12,"triangle",0.22); setTimeout(()=>this.beep(880,0.12,"triangle",0.22),120); }
    lose(){ this.beep(240,0.16,"sawtooth",0.22); setTimeout(()=>this.beep(180,0.16,"sawtooth",0.18),140); }
    meteor(){ this.beep(120,0.06,"sawtooth",0.16); setTimeout(()=>this.beep(220,0.05,"triangle",0.12),55); }
    skillReady(){ this.beep(720,0.08,"triangle",0.16); }
    sparkle(){ this.beep(980,0.06,"triangle",0.10); }
    hero(){ this.beep(610,0.06,"triangle",0.18); }
  }

  /* =========================
     Map
  ========================= */
  class GameMap {
    constructor(){
      this.grassPat = null;
      this.pathLens = [];
      this.pathTotal = 0;
      this.pathCum = [];
      this._computePath();
      this._makePatterns();
    }
    _computePath(){
      const pts = MAP.waypoints;
      this.pathLens.length = 0; this.pathCum.length = 0;
      let cum = 0; this.pathCum.push(0);
      for (let i=0;i<pts.length-1;i++){
        const dx = pts[i+1].x - pts[i].x, dy = pts[i+1].y - pts[i].y;
        const L = Math.hypot(dx,dy);
        this.pathLens.push(L);
        cum += L;
        this.pathCum.push(cum);
      }
      this.pathTotal = cum;
    }
    _makePatterns(){
      const oc = document.createElement("canvas");
      oc.width = 96; oc.height = 96;
      const g = oc.getContext("2d");
      const grad = g.createLinearGradient(0,0,96,96);
      grad.addColorStop(0, "#184c34");
      grad.addColorStop(1, "#0f3a28");
      g.fillStyle = grad; g.fillRect(0,0,96,96);
      for (let i=0;i<250;i++){
        const x = Math.random()*96, y = Math.random()*96;
        const r = 0.6 + Math.random()*1.8;
        const a = 0.06 + Math.random()*0.12;
        g.fillStyle = `rgba(230,255,240,${a})`;
        g.beginPath(); g.arc(x,y,r,0,TAU); g.fill();
      }
      for (let i=0;i<180;i++){
        const x = Math.random()*96, y = Math.random()*96;
        const r = 0.8 + Math.random()*2.0;
        const a = 0.06 + Math.random()*0.10;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.beginPath(); g.arc(x,y,r,0,TAU); g.fill();
      }
      this.grassPat = oc;
    }

    // Distance from a point to the polyline (for treasure placement)
    distanceToPath(x,y){
      const pts = MAP.waypoints;
      let best = 1e9;
      for (let i=0;i<pts.length-1;i++){
        const ax = pts[i].x, ay = pts[i].y;
        const bx = pts[i+1].x, by = pts[i+1].y;
        const vx = bx-ax, vy = by-ay;
        const wx = x-ax, wy = y-ay;
        const vv = vx*vx+vy*vy;
        const t = vv>0 ? clamp((wx*vx+wy*vy)/vv, 0, 1) : 0;
        const px = ax + vx*t, py = ay + vy*t;
        const d = Math.hypot(x-px, y-py);
        if (d < best) best = d;
      }
      return best;
    }

    posAlongPath(d){
      d = clamp(d, 0, this.pathTotal);
      const pts = MAP.waypoints;
      let seg = 0;
      while (seg < this.pathLens.length-1 && this.pathCum[seg+1] < d) seg++;
      const segStart = this.pathCum[seg];
      const t = this.pathLens[seg] > 0 ? (d - segStart) / this.pathLens[seg] : 0;
      const a = pts[seg], b = pts[seg+1];
      return { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t), seg, t };
    }

    render(ctx, view, time){
      const pat = ctx.createPattern(this.grassPat, "repeat");
      ctx.save();
      ctx.translate(view.offX, view.offY);
      ctx.scale(view.scale, view.scale);
      ctx.fillStyle = pat;
      ctx.fillRect(0,0, MAP.w, MAP.h);

      const vg = ctx.createRadialGradient(MAP.w*0.5, MAP.h*0.45, 80, MAP.w*0.5, MAP.h*0.45, 520);
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(1, "rgba(0,0,0,0.35)");
      ctx.fillStyle = vg;
      ctx.fillRect(0,0, MAP.w, MAP.h);

      this._drawRiver(ctx, time);
      this._drawRocks(ctx, time);
      this._drawPath(ctx);
      this._drawGate(ctx);
      this._drawPads(ctx, time);

      ctx.restore();
    }

    _drawPath(ctx){
      const pts = MAP.waypoints;
      const w = MAP.pathWidth;

      ctx.save();
      ctx.lineCap = "round"; ctx.lineJoin = "round";
      ctx.lineWidth = w + 10;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.moveTo(pts[0].x+3, pts[0].y+4);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x+3, pts[i].y+4);
      ctx.stroke();

      const grad = ctx.createLinearGradient(0,0,0,MAP.h);
      grad.addColorStop(0, "#a27b4e");
      grad.addColorStop(1, "#7b5a38");
      ctx.lineWidth = w;
      ctx.strokeStyle = grad;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();

      ctx.lineWidth = w + 4;
      ctx.strokeStyle = "rgba(25,20,14,0.55)";
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();

      ctx.lineWidth = 1;
      for (let i=0;i<240;i++){
        const t = i/239 * this.pathTotal;
        const p = this.posAlongPath(t);
        const jitter = (Math.random()*2-1)* (w*0.30);
        const jitter2= (Math.random()*2-1)* (w*0.30);
        ctx.fillStyle = `rgba(255,255,255,${0.02 + Math.random()*0.05})`;
        ctx.beginPath();
        ctx.arc(p.x + jitter, p.y + jitter2, 0.8 + Math.random()*1.6, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    }

    _drawRiver(ctx, time){
      const t = time*0.0005;
      const x0 = 520, y0 = 70;
      const x1 = 910, y1 = 190;
      const x2 = 840, y2 = 280;
      const x3 = 650, y3 = 220;
      const w = 40;

      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.30)";
      ctx.lineWidth = w + 10;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x0+4,y0+5);
      ctx.bezierCurveTo(x1+4,y1+5, x2+4,y2+5, x3+4,y3+5);
      ctx.stroke();

      const grad = ctx.createLinearGradient(520,60,900,290);
      grad.addColorStop(0, "#2c90c9");
      grad.addColorStop(1, "#1a4f8f");
      ctx.strokeStyle = grad;
      ctx.lineWidth = w;
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.bezierCurveTo(x1,y1, x2,y2, x3,y3);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.moveTo(x0+6, y0+6);
      ctx.bezierCurveTo(x1-25 + Math.sin(t)*8, y1-10, x2-35, y2+10, x3-10, y3-5);
      ctx.stroke();
      ctx.restore();
    }

    _drawRocks(ctx, time){
      const r = (x,y,s) => {
        ctx.save(); ctx.translate(x,y);
        ctx.rotate(Math.sin((x+y+time*0.001)*0.2)*0.04);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath(); ctx.ellipse(4,5, 14*s, 9*s, 0, 0, TAU); ctx.fill();
        const g = ctx.createLinearGradient(-10, -10, 20, 18);
        g.addColorStop(0, "#7b8796");
        g.addColorStop(1, "#434d5a");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(-14*s, 2*s);
        ctx.quadraticCurveTo(-10*s, -12*s, 4*s, -10*s);
        ctx.quadraticCurveTo(18*s, -8*s, 16*s, 5*s);
        ctx.quadraticCurveTo(8*s, 14*s, -6*s, 12*s);
        ctx.quadraticCurveTo(-16*s, 10*s, -14*s, 2*s);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1.2; ctx.stroke();
        ctx.restore();
      };
      r(520, 500, 1.1);
      r(600, 470, 0.9);
      r(90,  460, 1.0);
      r(130, 80,  0.8);
      r(900, 90,  0.85);
    }

    _drawGate(ctx){
      const drawGate = (x,y, label, col) => {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath(); ctx.ellipse(x+4,y+5, 26, 16, 0, 0, TAU); ctx.fill();
        const g = ctx.createLinearGradient(x-20,y-16,x+22,y+16);
        g.addColorStop(0, "#2a3646");
        g.addColorStop(1, "#141a22");
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.roundRect(x-22, y-18, 44, 36, 10); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1.5; ctx.stroke();

        ctx.fillStyle = col;
        ctx.font = "900 13px system-ui,Segoe UI,Arial";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(label, x, y);
        ctx.restore();
      };
      drawGate(MAP.start.x-20, MAP.start.y-10, "START", "#55b6ff");
      drawGate(MAP.end.x+10, MAP.end.y-10, "END", "#ff5a6a");
    }

    _drawPads(ctx, time){
      for (const p of MAP.pads){
        const pulse = 0.08*Math.sin((time*0.003) + p.id*1.3);
        ctx.save(); ctx.translate(p.x, p.y);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath(); ctx.ellipse(3,5, 21, 14, 0, 0, TAU); ctx.fill();
        const r = MAP.padR + pulse*6;
        ctx.fillStyle = "rgba(20,30,42,0.60)";
        ctx.beginPath(); ctx.arc(0,0,r,0,TAU); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0,r,0,TAU); ctx.stroke();

        ctx.strokeStyle = "rgba(85,182,255,0.18)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0,0, r*0.55, 0.2, 0.2+Math.PI*1.2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  /* =========================
     Entities
  ========================= */
  class Enemy {
    constructor(type, map, waveIndex){
      this.type = type;
      this.def = ENEMY_DEFS[type];
      this.map = map;
      this.waveIndex = waveIndex;

      this.maxHp = this.def.hp;
      this.hp = this.maxHp;
      this.speed = this.def.spd;
      this.armor = this.def.armor;
      this.mres  = this.def.mres;
      this.reward= this.def.reward;
      this.size  = this.def.size;
      this.color = this.def.color;
      this.flying= !!this.def.flying;
      this.dmgToLives = this.def.dmgToLives || 1;

      this.dist = 0;
      this.x = MAP.start.x;
      this.y = MAP.start.y;
      this.dead = false;
      this.reachedEnd = false;

      this.engagers = [];
      this.meleeCD = 0;

      this.slowMul = 1.0;
      this.slowT = 0;
      this.stunT = 0;

      this.roarCD = this.def.roarCD ?? 0;
      this.spawnCD = this.def.spawnCD ?? 0;
      this.healTick = 0;
      this.flashT = 0;
    }

    get progress(){ return this.dist / this.map.pathTotal; }

    applySlow(mult, dur){
      if (this.flying) return;
      if (dur > this.slowT || mult < this.slowMul){
        this.slowMul = Math.min(this.slowMul, mult);
        this.slowT = Math.max(this.slowT, dur);
      }
    }
    applyStun(dur){ this.stunT = Math.max(this.stunT, dur); }

    takeDamage(amount, dmgType){
      if (this.dead) return 0;
      let mult = 1.0;
      if (dmgType === "physical") mult *= (1 - this.armor);
      if (dmgType === "magic")    mult *= (1 - this.mres);
      if (dmgType === "true")     mult *= 1.0;
      const dealt = Math.max(1, amount * mult);
      this.hp -= dealt;
      this.flashT = 0.10;
      if (this.hp <= 0){
        this.hp = 0;
        this.dead = true;
      }
      return dealt;
    }

    update(dt, game){
      if (this.dead) return;

      if (this.flashT > 0) this.flashT -= dt;
      if (this.slowT > 0){
        this.slowT -= dt;
        if (this.slowT <= 0){ this.slowT = 0; this.slowMul = 1.0; }
      }
      if (this.stunT > 0) this.stunT -= dt;

      // shaman heal
      if (this.type === "shaman"){
        this.healTick += dt;
        if (this.healTick >= 0.20){
          this.healTick = 0;
          const R2 = (this.def.healR||80)**2;
          for (const e of game.enemies){
            if (e.dead || e.flying) continue;
            if (e === this) continue;
            if (dist2(this.x,this.y,e.x,e.y) <= R2){
              e.hp = Math.min(e.maxHp, e.hp + (this.def.healPS||6) * 0.20);
            }
          }
        }
      }

      // boss skills
      if (this.type === "boss"){
        this.roarCD -= dt;
        this.spawnCD -= dt;

        if (this.roarCD <= 0){
          this.roarCD = this.def.roarCD;
          const R2 = (this.def.roarR||120)**2;
          for (const s of game.getAllFighters()){
            if (s.dead) continue;
            if (dist2(this.x,this.y,s.x,s.y) <= R2){
              s.applyStun(this.def.roarDur || 1.1);
            }
          }
          game.shakeT = 0.22; game.shakeMag = 6;
          game.sfx.beep(120,0.12,"sawtooth",0.25);
          game.banner("BOSS ROAR! (cho√°ng l√≠nh)", "#ff5a6a", 1.8);
        }

        if (this.spawnCD <= 0){
          this.spawnCD = this.def.spawnCD;
          const n = this.def.spawnCount || 3;
          for (let i=0;i<n;i++){
            const e = new Enemy(this.def.spawnType || "goblin", game.map, game.waveManager.waveIndex);
            e.dist = Math.max(0, this.dist - 20 - i*10);
            const p = game.map.posAlongPath(e.dist);
            e.x = p.x; e.y = p.y;
            game.enemies.push(e);
          }
          game.sfx.wave();
          game.banner("Boss: 'xin th√™m v√†i minion nha üòà'", "#ffcc4d", 1.8);
        }
      }

      // engaged melee (ground only)
      if (!this.flying && this.engagers.length > 0){
        if (this.stunT > 0) return;
        const tgt = this.engagers[0];
        if (!tgt || tgt.dead){
          this.engagers = this.engagers.filter(s=>s && !s.dead);
          return;
        }
        this.meleeCD -= dt;
        if (this.meleeCD <= 0){
          this.meleeCD = this.def.meleeRate || 1.2;
          const s = this.engagers[Math.floor(Math.random()*this.engagers.length)];
          if (s && !s.dead){
            s.takeDamage(this.def.meleeDmg || 12);
            game.sfx.hurt();
            if (Math.random() < 0.22) game.spawnParticles(this.x, this.y, 6, "rgba(255,255,255,0.25)");
          }
        }
        return;
      }

      // move
      if (this.stunT > 0) return;
      const spd = this.speed * this.slowMul;
      this.dist += spd * dt;

      if (this.dist >= this.map.pathTotal){
        this.dist = this.map.pathTotal;
        this.reachedEnd = true;
        this.dead = true;
        return;
      }
      const p = this.map.posAlongPath(this.dist);
      this.x = p.x; this.y = p.y;
    }

    render(ctx){
      const r = this.size;
      ctx.save();

      if (!this.flying){
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath();
        ctx.ellipse(this.x+3, this.y+5, r*1.05, r*0.70, 0, 0, TAU);
        ctx.fill();
      } else {
        ctx.fillStyle = "rgba(0,0,0,0.22)";
        ctx.beginPath();
        ctx.ellipse(this.x+2, this.y+8, r*0.9, r*0.55, 0, 0, TAU);
        ctx.fill();
      }

      const g = ctx.createRadialGradient(this.x-r*0.35, this.y-r*0.35, r*0.25, this.x, this.y, r*1.2);
      g.addColorStop(0, this.flashT>0 ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.18)");
      g.addColorStop(1, this.color);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y - (this.flying ? 10 : 0), r, 0, TAU);
      ctx.fill();

      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "rgba(10,14,20,0.75)";
      ctx.font = `900 ${Math.max(10, r)}px system-ui,Segoe UI,Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const ch = (this.type==="goblin")?"G":
                 (this.type==="orc")?"O":
                 (this.type==="armored")?"A":
                 (this.type==="shaman")?"S":
                 (this.type==="runner")?"R":
                 (this.type==="flying")?"F":
                 (this.type==="tank")?"T":
                 (this.type==="boss")?"B":"?";
      ctx.fillText(ch, this.x, this.y - (this.flying ? 10 : 0) + 1);

      if (this.stunT > 0){
        ctx.strokeStyle = "rgba(255,255,255,0.65)";
        ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.arc(this.x, this.y - (this.flying ? 10 : 0), r+3, 0, TAU); ctx.stroke();
      } else if (this.slowT > 0){
        ctx.strokeStyle = "rgba(85,182,255,0.55)";
        ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.arc(this.x, this.y - (this.flying ? 10 : 0), r+3, 0, TAU); ctx.stroke();
      }

      // HP bar
      const barW = 30 + r*1.6;
      const barH = 6;
      const bx = this.x - barW/2;
      const by = (this.y - (this.flying ? 10 : 0)) - r - 14;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(bx, by, barW, barH);
      const pct = this.maxHp>0 ? (this.hp/this.maxHp) : 0;
      ctx.fillStyle = pct > 0.55 ? "#62d26f" : (pct>0.25 ? "#ffcc4d" : "#ff5a6a");
      ctx.fillRect(bx+1, by+1, (barW-2)*pct, barH-2);
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.strokeRect(bx,by,barW,barH);

      ctx.restore();
    }
  }

  class Projectile {
    constructor(kind, x,y, tx,ty, speed, dmg, dmgType, extra={}){
      this.kind = kind;
      this.x = x; this.y = y;
      this.tx = tx; this.ty = ty;
      this.speed = speed;
      this.dmg = dmg;
      this.dmgType = dmgType;
      this.dead = false;
      this.life = 4.0;

      this.target = extra.target || null;
      this.blastR = extra.blastR || 0;
      this.slowMul = extra.slowMul || 1.0;
      this.slowDur = extra.slowDur || 0;

      this.trail = [];
      this.trailMax = (kind==="shell") ? 10 : 7;

      this.arcT = 0;
      this.arcDur = extra.arcDur || 0.55;
      this.fromX = x; this.fromY = y;
      this.toX = tx; this.toY = ty;
    }
    update(dt, game){
      if (this.dead) return;
      this.life -= dt;
      if (this.life <= 0){ this.dead = true; return; }

      if (this.target && !this.target.dead){
        this.tx = this.target.x;
        this.ty = this.target.y - (this.target.flying ? 10 : 0);
      }

      if (this.kind === "shell"){
        this.arcT += dt;
        const t = clamp(this.arcT / this.arcDur, 0, 1);
        const tt = t*t*(3-2*t);
        const x = lerp(this.fromX, this.toX, tt);
        const y = lerp(this.fromY, this.toY, tt);
        const h = 70;
        const arc = Math.sin(Math.PI * tt) * h;
        this.x = x; this.y = y - arc;

        if (t >= 1){
          this.dead = true;
          game.explode(this.toX, this.toY, this.blastR, this.dmg, this.dmgType, {slowMul:this.slowMul, slowDur:this.slowDur});
          game.sfx.boom();
          game.spawnParticles(this.toX, this.toY, 16, "rgba(255,204,77,0.22)");
          game.shakeT = Math.max(game.shakeT, 0.10);
          game.shakeMag = Math.max(game.shakeMag, 4);
        }
      } else {
        const dx = this.tx - this.x;
        const dy = this.ty - this.y;
        const d = Math.hypot(dx,dy);
        if (d < 8){
          this.dead = true;
          let hit = null;
          if (this.target && !this.target.dead){
            hit = this.target;
            hit.takeDamage(this.dmg, this.dmgType);
          } else {
            hit = game.findEnemyNear(this.tx, this.ty, 14);
            if (hit) hit.takeDamage(this.dmg, this.dmgType);
          }
          game.sfx.shoot();
          if (hit && Math.random() < 0.55) game.spawnParticles(hit.x, hit.y - (hit.flying?10:0), 7, "rgba(255,255,255,0.20)");
          return;
        }
        const sp = this.speed;
        const nx = dx / d, ny = dy / d;
        this.x += nx * sp * dt;
        this.y += ny * sp * dt;
      }

      this.trail.push({x:this.x, y:this.y, t:0});
      if (this.trail.length > this.trailMax) this.trail.shift();
      for (const p of this.trail) p.t += dt;
    }
    render(ctx){
      ctx.save();
      if (this.trail.length >= 2){
        ctx.lineCap = "round"; ctx.lineJoin = "round";
        for (let i=0;i<this.trail.length-1;i++){
          const a = this.trail[i], b = this.trail[i+1];
          const alpha = clamp(1 - i/(this.trail.length), 0, 1) * 0.35;
          ctx.strokeStyle = (this.kind==="bolt") ? `rgba(127,231,255,${alpha})` :
                            (this.kind==="shell") ? `rgba(255,204,77,${alpha})` :
                            `rgba(232,241,255,${alpha})`;
          ctx.lineWidth = (this.kind==="shell") ? 4 : 3;
          ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
        }
      }

      if (this.kind === "arrow"){
        ctx.strokeStyle = "rgba(255,255,255,0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x-3,this.y-2);
        ctx.lineTo(this.x+4,this.y+3);
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath(); ctx.arc(this.x,this.y,2.2,0,TAU); ctx.fill();
      } else if (this.kind === "bolt"){
        ctx.fillStyle = "rgba(127,231,255,0.9)";
        ctx.beginPath(); ctx.arc(this.x,this.y,3.2,0,TAU); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.x,this.y,6.0,0,TAU); ctx.stroke();
      } else if (this.kind === "shell"){
        ctx.fillStyle = "rgba(255,204,77,0.95)";
        ctx.beginPath(); ctx.arc(this.x,this.y,4.5,0,TAU); ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 2; ctx.stroke();
      }
      ctx.restore();
    }
  }

  class Soldier {
    constructor(owner, idx){
      this.owner = owner;
      this.idx = idx;

      this.maxHp = 1;
      this.hp = 1;
      this.dmg = 1;
      this.rate = 1;
      this.spd = 120;

      this.x = owner.x + (idx===0 ? -10 : (idx===1 ? 10 : 0));
      this.y = owner.y + 18 + idx*6;

      this.dead = false;
      this.respawnT = 0;

      this.target = null;
      this.attackCD = 0;
      this.stunT = 0;

      this.state = "idle";
    }

    configureFromLevel(levelDef){
      this.maxHp = levelDef.sHp;
      this.hp = Math.min(this.hp, this.maxHp);
      this.dmg = levelDef.sDmg;
      this.rate = levelDef.sRate;
      this.spd = levelDef.sSpd;
    }

    applyStun(dur){ this.stunT = Math.max(this.stunT, dur); }

    takeDamage(amount){
      if (this.dead) return;
      this.hp -= amount;
      if (this.hp <= 0){
        this.hp = 0;
        this.dead = true;
        this.state = "dead";
        this.target = null;
        this.respawnT = this.owner.levelDef().respawn;
      }
    }

    update(dt, game){
      if (this.dead){
        this.respawnT -= dt;
        if (this.respawnT <= 0){
          this.dead = false;
          this.hp = this.maxHp;
          this.x = this.owner.x + (this.idx===0 ? -12 : (this.idx===1 ? 12 : 0));
          this.y = this.owner.y + 22 + this.idx*6;
          this.state = "move";
        }
        return;
      }

      if (this.stunT > 0){
        this.stunT -= dt;
        return;
      }

      if (!this.target || this.target.dead || this.target.flying){
        this.target = null;
        this.state = "move";
      }

      const rx = this.owner.rallyX;
      const ry = this.owner.rallyY;

      if (!this.target){
        const blockR = this.owner.levelDef().blockR;
        const R2 = blockR*blockR;
        let best = null;
        let bestProg = -1;
        for (const e of game.enemies){
          if (e.dead || e.flying) continue;
          if (dist2(rx,ry,e.x,e.y) > R2) continue;
          if (e.engagers.length >= 2) continue;
          if (e.progress > bestProg){
            bestProg = e.progress;
            best = e;
          }
        }
        if (best){
          this.target = best;
          best.engagers.push(this);
          this.state = "fight";
          this.attackCD = 0.18 + Math.random()*0.18;
        }
      }

      if (this.state === "fight" && this.target && !this.target.dead){
        const tx = this.target.x;
        const ty = this.target.y;
        const d = Math.hypot(tx - this.x, ty - this.y);
        if (d > 18){
          const nx = (tx - this.x) / d;
          const ny = (ty - this.y) / d;
          this.x += nx * this.spd * dt;
          this.y += ny * this.spd * dt;
        }

        this.attackCD -= dt;
        if (this.attackCD <= 0){
          this.attackCD = this.rate;
          this.target.takeDamage(this.dmg, "physical");
          game.sfx.hurt();
          if (Math.random() < 0.25) game.spawnParticles(this.target.x, this.target.y, 5, "rgba(85,182,255,0.25)");
        }
        return;
      }

      this.state = "move";
      const dx = rx - this.x;
      const dy = ry - this.y;
      const d = Math.hypot(dx,dy);
      if (d > 6){
        const nx = dx / d, ny = dy / d;
        this.x += nx * this.spd * dt;
        this.y += ny * this.spd * dt;
      } else {
        this.state = "idle";
      }
    }

    render(ctx){
      if (this.dead) return;
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.ellipse(this.x+3,this.y+5, 10, 6, 0, 0, TAU);
      ctx.fill();

      const g = ctx.createRadialGradient(this.x-4,this.y-4,2,this.x,this.y,14);
      g.addColorStop(0, this.stunT>0 ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.18)");
      g.addColorStop(1, "#55b6ff");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x,this.y,8.5,0,TAU);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2; ctx.stroke();

      ctx.fillStyle = "rgba(10,14,20,0.75)";
      ctx.font = "900 10px system-ui,Segoe UI,Arial";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("I", this.x, this.y+1);

      const barW = 26, barH = 5;
      const bx = this.x - barW/2, by = this.y - 18;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(bx,by,barW,barH);
      const pct = this.maxHp>0 ? (this.hp/this.maxHp) : 0;
      ctx.fillStyle = pct>0.55 ? "#62d26f" : (pct>0.25 ? "#ffcc4d" : "#ff5a6a");
      ctx.fillRect(bx+1,by+1,(barW-2)*pct,barH-2);
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.strokeRect(bx,by,barW,barH);

      ctx.restore();
    }
  }

  class Reinforcement {
    constructor(x,y, idx, def){
      this.x = x + (idx===0 ? -10 : 10);
      this.y = y + (idx===0 ?  6  : -6);
      this.baseX = x;
      this.baseY = y;

      this.maxHp = def.hp;
      this.hp = def.hp;
      this.dmg = def.dmg;
      this.rate = def.rate;
      this.spd = def.spd;
      this.blockR = def.blockR;

      this.maxLifeT = def.duration;
      this.lifeT = def.duration;

      this.dead = false;
      this.target = null;
      this.attackCD = 0.15 + Math.random()*0.2;
      this.stunT = 0;
      this.state = "idle";
    }

    applyStun(dur){ this.stunT = Math.max(this.stunT, dur); }

    takeDamage(amount){
      if (this.dead) return;
      this.hp -= amount;
      if (this.hp <= 0){
        this.hp = 0;
        this.dead = true;
        this.target = null;
      }
    }

    update(dt, game){
      if (this.dead) return;

      this.lifeT -= dt;
      if (this.lifeT <= 0){
        this.dead = true;
        if (this.target && this.target.engagers){
          this.target.engagers = this.target.engagers.filter(s=>s!==this);
        }
        this.target = null;
        return;
      }

      if (this.stunT > 0){
        this.stunT -= dt;
        return;
      }

      if (!this.target || this.target.dead || this.target.flying){
        this.target = null;
      }

      if (!this.target){
        const R2 = this.blockR*this.blockR;
        let best = null, bestProg = -1;
        for (const e of game.enemies){
          if (e.dead || e.flying) continue;
          if (dist2(this.baseX,this.baseY,e.x,e.y) > R2) continue;
          if (e.engagers.length >= 2) continue;
          if (e.progress > bestProg){
            bestProg = e.progress;
            best = e;
          }
        }
        if (best){
          this.target = best;
          best.engagers.push(this);
          this.state = "fight";
          this.attackCD = 0.12 + Math.random()*0.2;
        } else {
          this.state = "idle";
        }
      }

      if (this.target && !this.target.dead){
        const tx = this.target.x, ty = this.target.y;
        const d = Math.hypot(tx-this.x, ty-this.y);
        if (d > 18){
          const nx = (tx-this.x)/d, ny = (ty-this.y)/d;
          this.x += nx*this.spd*dt;
          this.y += ny*this.spd*dt;
        }
        this.attackCD -= dt;
        if (this.attackCD <= 0){
          this.attackCD = this.rate;
          this.target.takeDamage(this.dmg, "physical");
          game.sfx.hurt();
          if (Math.random() < 0.25) game.spawnParticles(tx, ty, 4, "rgba(98,210,111,0.22)");
        }
        return;
      }

      const dx = this.baseX - this.x;
      const dy = this.baseY - this.y;
      const d = Math.hypot(dx,dy);
      if (d > 10){
        const nx = dx/d, ny = dy/d;
        this.x += nx*this.spd*dt;
        this.y += ny*this.spd*dt;
      }
    }

    render(ctx){
      if (this.dead) return;
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.ellipse(this.x+3,this.y+5, 10, 6, 0, 0, TAU);
      ctx.fill();

      const g = ctx.createRadialGradient(this.x-4,this.y-4,2,this.x,this.y,14);
      g.addColorStop(0, this.stunT>0 ? "rgba(255,255,255,0.85)" : "rgba(255,255,255,0.18)");
      g.addColorStop(1, "#62d26f");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x,this.y,8.5,0,TAU);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2; ctx.stroke();

      ctx.fillStyle = "rgba(10,14,20,0.75)";
      ctx.font = "900 10px system-ui,Segoe UI,Arial";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("R", this.x, this.y+1);

      // HP bar
      const barW = 26, barH = 5;
      const bx = this.x - barW/2, by = this.y - 18;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(bx,by,barW,barH);
      const pct = this.maxHp>0 ? (this.hp/this.maxHp) : 0;
      ctx.fillStyle = pct>0.55 ? "#62d26f" : (pct>0.25 ? "#ffcc4d" : "#ff5a6a");
      ctx.fillRect(bx+1,by+1,(barW-2)*pct,barH-2);
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.strokeRect(bx,by,barW,barH);

      // lifetime ring
      const lp = clamp(this.lifeT / Math.max(0.001,this.maxLifeT), 0, 1);
      ctx.strokeStyle = `rgba(255,255,255,${0.08 + 0.14*lp})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x,this.y, 13, -Math.PI/2, -Math.PI/2 + TAU*lp);
      ctx.stroke();

      ctx.restore();
    }
  }

  // Hero (fun extra)
  class Hero {
    constructor(x,y){
      this.name = HERO_DEF.name;
      this.x = x; this.y = y;
      this.maxHp = HERO_DEF.maxHp;
      this.hp = this.maxHp;
      this.dmg = HERO_DEF.dmg;
      this.rate = HERO_DEF.rate;
      this.spd = HERO_DEF.spd;
      this.aggroR = HERO_DEF.aggroR;
      this.blockR = HERO_DEF.blockR;
      this.contactR = HERO_DEF.contactR;

      this.dead = false;
      this.respawnT = 0;

      this.destX = x; this.destY = y;
      this.target = null;
      this.attackCD = 0.15;
      this.stunT = 0;

      this.selected = false;
      this.pulseT = 0;

      this.smashCd = 0;
      this.smashMax = HERO_DEF.smash.cdMax;

      this.bubble = null; // {txt,t,dur}
    }

    say(txt, dur=1.8){
      this.bubble = {txt, t:0, dur};
    }

    applyStun(dur){ this.stunT = Math.max(this.stunT, dur); }

    takeDamage(amount){
      if (this.dead) return;
      this.hp -= amount;
      if (this.hp <= 0){
        this.hp = 0;
        this.dead = true;
        this.respawnT = HERO_DEF.respawn;
        if (this.target && this.target.engagers){
          this.target.engagers = this.target.engagers.filter(s=>s!==this);
        }
        this.target = null;
      }
    }

    setDestination(x,y){
      this.destX = clamp(x, 0, MAP.w);
      this.destY = clamp(y, 0, MAP.h);
    }

    tryAutoTarget(game){
      if (this.dead) return;
      const R2 = this.aggroR*this.aggroR;
      let best=null, bestProg=-1;
      for (const e of game.enemies){
        if (e.dead || e.flying) continue;
        if (dist2(this.x,this.y,e.x,e.y) > R2) continue;
        if (e.progress > bestProg){ bestProg = e.progress; best = e; }
      }
      if (best){
        this.target = best;
        if (!best.engagers.includes(this)) best.engagers.push(this);
      }
    }

    castSmash(game){
      if (this.dead) return false;
      if (this.smashCd > 0) return false;
      this.smashCd = this.smashMax;
      const s = HERO_DEF.smash;

      this.say("üí• SMASH!", 1.2);
      game.banner("Hero Smash! üí•", "#ffcc4d", 1.4);
      game.explode(this.x, this.y, s.radius, s.damage, "physical", {stun:s.stun, slowMul:s.slowMul, slowDur:s.slowDur});
      game.spawnParticles(this.x, this.y, 42, "rgba(255,90,106,0.18)");
      game.spawnParticles(this.x, this.y, 28, "rgba(255,204,77,0.18)");
      game.shakeT = Math.max(game.shakeT, 0.18);
      game.shakeMag = Math.max(game.shakeMag, 7);
      game.sfx.beep(140,0.10,"sawtooth",0.25);
      return true;
    }

    update(dt, dtRaw, game){
      this.pulseT += dtRaw;

      if (this.smashCd > 0) this.smashCd = Math.max(0, this.smashCd - dtRaw);

      if (this.bubble){
        this.bubble.t += dtRaw;
        if (this.bubble.t >= this.bubble.dur) this.bubble = null;
      }

      if (this.dead){
        this.respawnT -= dtRaw;
        if (this.respawnT <= 0){
          this.dead = false;
          this.hp = this.maxHp;
          this.x = 470; this.y = 470;
          this.destX = this.x; this.destY = this.y;
          this.say("Ta ƒë√£ tr·ªü l·∫°i!", 1.6);
          game.banner("Hero respawn!", "#62d26f", 1.3);
        }
        return;
      }

      if (this.stunT > 0){
        this.stunT -= dt;
        return;
      }

      if (this.target && (this.target.dead || this.target.flying)){
        if (this.target && this.target.engagers) this.target.engagers = this.target.engagers.filter(s=>s!==this);
        this.target = null;
      }

      // If far from destination and no close target -> move
      if (!this.target){
        this.tryAutoTarget(game);
      }

      if (this.target && !this.target.dead){
        const tx = this.target.x, ty = this.target.y;
        const d = Math.hypot(tx-this.x, ty-this.y);
        if (d > this.contactR){
          const nx = (tx-this.x)/d, ny = (ty-this.y)/d;
          this.x += nx*this.spd*dt;
          this.y += ny*this.spd*dt;
        }
        this.attackCD -= dt;
        if (this.attackCD <= 0){
          this.attackCD = this.rate;
          // tiny "hero crit" sometimes
          let dmg = this.dmg;
          if (Math.random() < 0.10){ dmg *= 1.8; game.floatText(tx, ty-18, "CRIT!", "#ffcc4d", 0.55); }
          this.target.takeDamage(dmg, "physical");
          game.sfx.hurt();
          game.spawnParticles(tx, ty, 8, "rgba(255,255,255,0.22)");
        }
        return;
      }

      // move toward dest
      const dx = this.destX - this.x;
      const dy = this.destY - this.y;
      const d = Math.hypot(dx,dy);
      if (d > 6){
        const nx = dx/d, ny = dy/d;
        this.x += nx*this.spd*dt;
        this.y += ny*this.spd*dt;
      }
    }

    render(ctx){
      if (this.dead) return;
      ctx.save();

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.ellipse(this.x+3, this.y+6, 14, 9, 0, 0, TAU);
      ctx.fill();

      // body
      const g = ctx.createRadialGradient(this.x-6, this.y-6, 2, this.x, this.y, 18);
      g.addColorStop(0, "rgba(255,255,255,0.18)");
      g.addColorStop(1, "#695cd2");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 12.5, 0, TAU);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // face icon
      ctx.fillStyle = "rgba(10,14,20,0.75)";
      ctx.font = "900 12px system-ui,Segoe UI,Arial";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("H", this.x, this.y+1);

      // selected ring
      if (this.selected){
        const pulse = 0.5 + 0.5*Math.sin(this.pulseT*6);
        ctx.strokeStyle = `rgba(179,136,255,${0.24 + pulse*0.10})`;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(this.x,this.y, 18, 0, TAU); ctx.stroke();
      }

      // HP
      const barW = 44, barH = 6;
      const bx = this.x - barW/2;
      const by = this.y - 26;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(bx,by,barW,barH);
      const pct = this.hp/this.maxHp;
      ctx.fillStyle = pct>0.55 ? "#62d26f" : (pct>0.25 ? "#ffcc4d" : "#ff5a6a");
      ctx.fillRect(bx+1,by+1,(barW-2)*pct,barH-2);
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.strokeRect(bx,by,barW,barH);

      // bubble
      if (this.bubble){
        const k = clamp(this.bubble.t / this.bubble.dur, 0, 1);
        const a = (k < 0.15) ? (k/0.15) : (k > 0.85 ? (1 - (k-0.85)/0.15) : 1);
        const txt = this.bubble.txt;
        ctx.globalAlpha = a;
        ctx.font = "900 12px system-ui,Segoe UI,Arial";
        const w = ctx.measureText(txt).width + 14;
        const h = 22;
        const px = this.x - w/2;
        const py = this.y - 52;
        ctx.fillStyle = "rgba(10,14,20,0.85)";
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.roundRect(px, py, w, h, 10);
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = "rgba(232,241,255,0.92)";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(txt, this.x, py + h/2);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }

    renderRange(ctx){
      ctx.save();
      ctx.fillStyle = "rgba(179,136,255,0.08)";
      ctx.strokeStyle = "rgba(179,136,255,0.20)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(this.x,this.y, this.blockR, 0, TAU); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  }

  /* =========================
     Towers
  ========================= */
  class Tower {
    constructor(type, x,y, padId){
      this.type = type;
      this.def = TOWER_DEFS[type];
      this.x = x; this.y = y;
      this.padId = padId;
      this.level = 1;
      this.spent = 0;
      this.cooldown = 0;
      this.selected = false;

      this.rallyX = x + 38;
      this.rallyY = y + 18;

      this.pulseT = 0;
    }

    levelDef(){ return this.def.levels[this.level-1]; }
    totalCost(){ return this.spent; }
    canUpgrade(){ return this.level < 3; }
    upgradeCost(){ return this.canUpgrade() ? this.def.levels[this.level].up : 0; }
    upgrade(){ if (!this.canUpgrade()) return false; this.level++; return true; }

    update(dt, game){
      this.pulseT += dt;
      if (this.type === "barracks"){
        this._ensureSoldiers(game);
        return;
      }

      this.cooldown -= dt;
      if (this.cooldown > 0) return;

      const ld = this.levelDef();
      const range = ld.range;
      const R2 = range*range;

      let best = null;
      let bestProg = -1;
      for (const e of game.enemies){
        if (e.dead) continue;
        if (this.type === "artillery" && e.flying) continue;
        const ey = e.y - (e.flying ? 10 : 0);
        if (dist2(this.x,this.y,e.x,ey) > R2) continue;
        if (e.progress > bestProg){
          bestProg = e.progress;
          best = e;
        }
      }
      if (!best) return;

      this.cooldown = ld.rate;
      if (this.type === "archer"){
        let dmg = ld.dmg;
        if (Math.random() < (ld.crit || 0)){
          dmg *= 1.75;
          game.sfx.beep(980,0.03,"triangle",0.14);
          if (Math.random() < 0.25) game.floatText(best.x, best.y-22, "‚ú®", "#ffcc4d", 0.55);
        } else {
          game.sfx.shoot();
        }
        game.projectiles.push(new Projectile("arrow", this.x, this.y-10, best.x, best.y - (best.flying ? 10 : 0), ld.projSpd, dmg, "physical", {target: best}));
      } else if (this.type === "mage"){
        game.sfx.shoot();
        if (Math.random() < 0.20) game.spawnParticles(this.x, this.y-12, 4, "rgba(127,231,255,0.25)");
        game.projectiles.push(new Projectile("bolt", this.x, this.y-12, best.x, best.y - (best.flying ? 10 : 0), ld.projSpd, ld.dmg, "magic", {target: best}));
      } else if (this.type === "artillery"){
        game.sfx.shoot();
        const tx = best.x, ty = best.y;
        const arcDur = Math.max(0.42, Math.min(0.70, Math.hypot(tx-this.x, ty-this.y) / ld.projSpd));
        game.projectiles.push(new Projectile("shell", this.x, this.y-14, tx, ty, ld.projSpd, ld.dmg, "physical", {
          blastR: ld.blastR, slowMul: ld.slowMul, slowDur: ld.slowDur, arcDur
        }));
      }
    }

    _ensureSoldiers(game){
      const ld = this.levelDef();
      if (!this._soldiers) this._soldiers = [];
      for (const s of this._soldiers) s.configureFromLevel(ld);
      while (this._soldiers.length < ld.soldiers){
        const s = new Soldier(this, this._soldiers.length);
        s.configureFromLevel(ld);
        this._soldiers.push(s);
        game.soldiers.push(s);
      }
    }

    render(ctx){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.beginPath();
      ctx.ellipse(this.x+4,this.y+7, 26, 16, 0, 0, TAU);
      ctx.fill();

      const baseGrad = ctx.createLinearGradient(this.x-26,this.y-22,this.x+26,this.y+22);
      baseGrad.addColorStop(0, "rgba(40,58,74,0.95)");
      baseGrad.addColorStop(1, "rgba(16,22,30,0.95)");
      ctx.fillStyle = baseGrad;
      ctx.beginPath();
      ctx.roundRect(this.x-26, this.y-22, 52, 44, 12);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      ctx.stroke();

      const lv = this.level;
      if (this.type === "archer"){
        const col = lv===1 ? "#d9f2ff" : (lv===2 ? "#9de8ff" : "#55b6ff");
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.roundRect(this.x-16, this.y-30, 32, 24, 10); ctx.fill();
        ctx.fillStyle = "rgba(10,14,20,0.65)";
        ctx.font = "900 14px system-ui,Segoe UI,Arial";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("üèπ", this.x, this.y-18);
      } else if (this.type === "mage"){
        const col = lv===1 ? "#d7c2ff" : (lv===2 ? "#b388ff" : "#7a52ff");
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.roundRect(this.x-15, this.y-32, 30, 28, 12); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.x, this.y-22, 10+lv*2, 0, TAU); ctx.stroke();
        ctx.fillStyle = "rgba(10,14,20,0.65)";
        ctx.font = "900 14px system-ui,Segoe UI,Arial";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("üîÆ", this.x, this.y-19);
      } else if (this.type === "barracks"){
        const col = lv===1 ? "#a7d3ff" : (lv===2 ? "#7cc6ff" : "#55b6ff");
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.roundRect(this.x-18, this.y-30, 36, 26, 10); ctx.fill();
        ctx.fillStyle = "rgba(10,14,20,0.65)";
        ctx.font = "900 14px system-ui,Segoe UI,Arial";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("üõ°Ô∏è", this.x, this.y-18);

        ctx.strokeStyle = "rgba(255,255,255,0.20)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.rallyX, this.rallyY-16);
        ctx.lineTo(this.rallyX, this.rallyY+10);
        ctx.stroke();
        ctx.fillStyle = "rgba(85,182,255,0.55)";
        ctx.beginPath();
        ctx.moveTo(this.rallyX, this.rallyY-16);
        ctx.lineTo(this.rallyX+14, this.rallyY-10);
        ctx.lineTo(this.rallyX, this.rallyY-6);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath(); ctx.arc(this.rallyX, this.rallyY+10, 4, 0, TAU); ctx.fill();
      } else if (this.type === "artillery"){
        const col = lv===1 ? "#ffe4a0" : (lv===2 ? "#ffcf6e" : "#ffb703");
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.roundRect(this.x-17, this.y-34, 34, 30, 12); ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x-10, this.y-20);
        ctx.lineTo(this.x+18, this.y-34);
        ctx.stroke();
        ctx.fillStyle = "rgba(10,14,20,0.65)";
        ctx.font = "900 14px system-ui,Segoe UI,Arial";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("üí£", this.x-2, this.y-18);
      }

      if (this.selected){
        const pulse = 0.5 + 0.5*Math.sin(this.pulseT*6);
        ctx.strokeStyle = `rgba(85,182,255,${0.22 + pulse*0.10})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(this.x-30, this.y-38, 60, 60, 14);
        ctx.stroke();
      }
      ctx.restore();
    }

    renderRange(ctx){
      const ld = this.levelDef();
      const r = (this.type==="barracks") ? ld.blockR : ld.range;
      ctx.save();
      ctx.fillStyle = "rgba(85,182,255,0.08)";
      ctx.strokeStyle = "rgba(85,182,255,0.22)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, 0, TAU);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(232,241,255,0.35)";
      ctx.beginPath(); ctx.arc(this.x,this.y,3,0,TAU); ctx.fill();
      ctx.restore();
    }
  }

  /* =========================
     Wave Manager
  ========================= */
  class WaveManager {
    constructor(game){
      this.game = game;
      this.waveIndex = 0;
      this.state = "idle"; // idle, countdown, spawning, done
      this.countdown = 6.0;
      this.groupIndex = 0;
      this.spawnLeft = 0;
      this.spawnT = 0;
      this.groupDelayT = 0;
      this.started = false;
    }
    reset(){
      this.waveIndex = 0;
      this.state = "countdown";
      this.countdown = 6.0;
      this.groupIndex = 0;
      this.spawnLeft = 0;
      this.spawnT = 0;
      this.groupDelayT = 0;
      this.started = false;
    }
    get maxWaves(){ return WAVES.length; }
    canStartWave(){ return (this.state === "countdown" || this.state === "idle") && this.waveIndex < WAVES.length; }

    startWave(early=false){
      if (!this.canStartWave()) return false;

      if (early && this.state === "countdown"){
        const bonus = Math.floor(this.countdown * 2.5);
        if (bonus > 0){
          this.game.gold += bonus;
          const p0 = this.game.map.posAlongPath(0);
          this.game.floatText(p0.x + 40, p0.y - 40, `+${bonus} gold`, "#ffcc4d");
        }
      }

      const next = this.waveIndex + 1;
      this.game.banner(`Wave ${next} ÏãúÏûë!`, "#e8f1ff", 1.6);
      if (this.waveIndex === WAVES.length-1){
        this.game.banner("‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è", "#ff5a6a", 2.1);
      } else if (Math.random() < 0.50){
        this.game.banner(JOKES[Math.floor(Math.random()*JOKES.length)], "#a9b7c6", 2.0);
      }

      this.state = "spawning";
      this.started = true;
      this.countdown = 0;

      this.groupIndex = 0;
      this._setupGroup();
      this.game.sfx.wave();
      return true;
    }

    _setupGroup(){
      const w = WAVES[this.waveIndex];
      if (!w) return;
      const g = w.groups[this.groupIndex];
      this.spawnLeft = g ? g.count : 0;
      this.spawnT = 0.0;
      this.groupDelayT = g ? (g.delay || 0) : 0;
    }

    update(dt){
      if (this.waveIndex >= WAVES.length){
        if (this.game.enemies.length === 0 && this.state !== "done"){
          this.state = "done";
          this.game.onVictory();
        }
        return;
      }

      if (this.state === "idle"){
        this.state = "countdown";
        this.countdown = 6.0;
        return;
      }

      if (this.state === "countdown"){
        this.countdown -= dt;
        if (this.countdown <= 0){
          this.countdown = 0;
          this.startWave(false);
        }
        return;
      }

      if (this.state === "spawning"){
        const w = WAVES[this.waveIndex];
        const g = w.groups[this.groupIndex];
        if (!g){ this._finishWave(); return; }

        if (this.groupDelayT > 0){
          this.groupDelayT -= dt;
          return;
        }

        this.spawnT -= dt;
        if (this.spawnLeft > 0 && this.spawnT <= 0){
          this.spawnT = g.interval;
          this.spawnLeft--;
          this.game.spawnEnemy(g.type);
        }

        if (this.spawnLeft <= 0){
          this.groupIndex++;
          if (this.groupIndex >= w.groups.length){
            this._finishWave();
          } else {
            this._setupGroup();
          }
        }
      }
    }

    _finishWave(){
      this.waveIndex++;
      if (this.waveIndex >= WAVES.length){
        this.state = "waitingClear";
        return;
      }
      this.state = "countdown";
      this.countdown = 6.0;
      this.started = false;
      if (Math.random() < 0.45) this.game.banner("Ngh·ªâ t√≠... r·ªìi l·∫°i chi·∫øn! üòÑ", "#a9b7c6", 1.6);
    }
  }

  /* =========================
     UI
  ========================= */
  class UI {
    constructor(game){
      this.game = game;

      this.elGold = document.getElementById("uiGold");
      this.elLives= document.getElementById("uiLives");
      this.elWave = document.getElementById("uiWave");
      this.elWaveMax = document.getElementById("uiWaveMax");
      this.elWaveState = document.getElementById("uiWaveState");

      this.btnRain = document.getElementById("btnRain");
      this.btnRein = document.getElementById("btnRein");

      this.btnHero = document.getElementById("btnHero");
      this.btnSmash= document.getElementById("btnSmash");

      this.btnStart = document.getElementById("btnStart");
      this.btnPause = document.getElementById("btnPause");
      this.btnSpeed = document.getElementById("btnSpeed");

      this.buildPanel = document.getElementById("buildPanel");
      this.buildGrid  = document.getElementById("buildGrid");

      this.towerPanel = document.getElementById("towerPanel");
      this.tpTitle = document.getElementById("tpTitle");
      this.tpSub   = document.getElementById("tpSub");
      this.tpStats = document.getElementById("tpStats");
      this.btnUpgrade = document.getElementById("btnUpgrade");
      this.btnSell = document.getElementById("btnSell");
      this.tpExtra = document.getElementById("tpExtra");
      this.btnRally = document.getElementById("btnRally");
      this.btnCancelRally = document.getElementById("btnCancelRally");

      this.heroPanel = document.getElementById("heroPanel");
      this.hpTitle = document.getElementById("hpTitle");
      this.hpSub   = document.getElementById("hpSub");
      this.hpStats = document.getElementById("hpStats");
      this.btnHpSmash = document.getElementById("btnHpSmash");
      this.btnHpClose = document.getElementById("btnHpClose");

      this.overlay = document.getElementById("overlay");
      this.ovTitle = document.getElementById("ovTitle");
      this.ovDesc  = document.getElementById("ovDesc");
      this.btnRestart = document.getElementById("btnRestart");
      this.btnCloseOv = document.getElementById("btnCloseOv");

      this.tip = document.getElementById("tip");
      this._hookTooltips();

      // Skills buttons
      this.btnRain.addEventListener("click", () => { game.sfx.click(); game.tryEnterCastMode("rain"); });
      this.btnRein.addEventListener("click", () => { game.sfx.click(); game.tryEnterCastMode("rein"); });

      // Hero
      this.btnHero.addEventListener("click", () => { game.sfx.click(); game.toggleHeroSelect(); });
      this.btnSmash.addEventListener("click", () => { game.sfx.click(); game.tryHeroSmash(); });

      // Core buttons
      this.btnStart.addEventListener("click", () => {
        game.sfx.click();
        if (game.waveManager.state === "countdown") game.waveManager.startWave(true);
        else if (game.waveManager.canStartWave()) game.waveManager.startWave(false);
      });
      this.btnPause.addEventListener("click", () => { game.sfx.click(); game.togglePause(); });
      this.btnSpeed.addEventListener("click", () => { game.sfx.click(); game.toggleSpeed(); });

      this.btnUpgrade.addEventListener("click", () => { game.sfx.click(); game.tryUpgradeSelected(); });
      this.btnSell.addEventListener("click", () => { game.sfx.click(); game.trySellSelected(); });
      this.btnRally.addEventListener("click", () => { game.sfx.click(); game.enterRallyMode(); });
      this.btnCancelRally.addEventListener("click", () => { game.sfx.click(); game.exitRallyMode(); });

      this.btnHpSmash.addEventListener("click", () => { game.sfx.click(); game.tryHeroSmash(); });
      this.btnHpClose.addEventListener("click", () => { game.sfx.click(); this.hideHeroPanel(); });

      this.btnRestart.addEventListener("click", () => { game.sfx.click(); game.reset(); });
      this.btnCloseOv.addEventListener("click", () => { game.sfx.click(); this.hideOverlay(); });

      this._buildButtons();
    }

    _hookTooltips(){
      const show = (e) => {
        const t = e.target;
        const title = t.getAttribute("data-tip-title");
        const desc  = t.getAttribute("data-tip-desc");
        if (!title) return;
        this.tip.innerHTML = `<div class="t">${title}</div><div class="d">${desc||""}</div>`;
        this.tip.style.display = "block";
        this._moveTip(e);
      };
      const move = (e) => this._moveTip(e);
      const hide = () => { this.tip.style.display="none"; };

      document.addEventListener("mouseover", (e)=>show(e), true);
      document.addEventListener("mousemove", (e)=>move(e), true);
      document.addEventListener("mouseout", (e)=>hide(e), true);
    }
    _moveTip(e){
      if (this.tip.style.display !== "block") return;
      const pad = 12;
      const rect = this.tip.getBoundingClientRect();
      let x = e.clientX + pad;
      let y = e.clientY + pad;
      if (x + rect.width > innerWidth - 6) x = innerWidth - rect.width - 6;
      if (y + rect.height > innerHeight - 6) y = innerHeight - rect.height - 6;
      this.tip.style.left = x + "px";
      this.tip.style.top  = y + "px";
    }

    _buildButtons(){
      const order = ["archer","mage","barracks","artillery"];
      this.buildGrid.innerHTML = "";
      for (const key of order){
        const def = TOWER_DEFS[key];
        const lvl1 = def.levels[0];
        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `
          <div class="row">
            <div style="display:flex;align-items:center;gap:8px;">
              <div style="font-size:18px">${def.icon}</div>
              <div style="font-weight:900">${def.name}</div>
            </div>
            <div class="price">${lvl1.build}</div>
          </div>
          <div class="tag">${def.desc}</div>
          <button class="btn-good" style="border-radius:12px;padding:10px 12px;"
            data-tip-title="${def.name}" data-tip-desc="${def.desc}\nGi√°: ${lvl1.build} gold">Build</button>
        `;
        const btn = card.querySelector("button");
        btn.addEventListener("click", () => { this.game.sfx.build(); this.game.tryBuildOnSelectedPad(key); });
        this.buildGrid.appendChild(card);
      }
    }

    update(){
      const g = this.game;
      this.elGold.textContent = fmt(g.gold);
      this.elLives.textContent = fmt(g.lives);
      this.elWaveMax.textContent = fmt(g.waveManager.maxWaves);
      const wi = Math.min(g.waveManager.waveIndex + 1, g.waveManager.maxWaves);
      this.elWave.textContent = fmt(wi);

      const wm = g.waveManager;
      let stateTxt = "";
      if (wm.waveIndex >= wm.maxWaves) stateTxt = " done";
      else if (wm.state === "countdown") stateTxt = ` (in ${Math.ceil(wm.countdown)}s)`;
      else if (wm.state === "spawning") stateTxt = " (active)";
      this.elWaveState.textContent = stateTxt;

      // Start button
      if (wm.waveIndex >= wm.maxWaves){
        this.btnStart.disabled = true;
        this.btnStart.textContent = "All Waves";
      } else {
        if (wm.state === "countdown"){
          const bonus = Math.floor(wm.countdown * 2.5);
          this.btnStart.disabled = g.paused || g.gameOver;
          this.btnStart.textContent = `Start Wave (+${bonus}g)`;
        } else if (wm.state === "spawning"){
          this.btnStart.textContent = "Wave Running";
          this.btnStart.disabled = true;
        } else {
          this.btnStart.textContent = "Start Wave";
          this.btnStart.disabled = g.paused || g.gameOver;
        }
      }

      this.btnPause.textContent = g.paused ? "Resume" : "Pause";
      this.btnSpeed.textContent = g.timeScale === 2 ? "x2" : "x1";

      this._syncSkillButtons();
      this._syncHeroButtons();
      this._syncPanels();
    }

    _syncSkillButtons(){
      const g = this.game;
      const r = g.skills.rain.cd;
      const e = g.skills.rein.cd;

      const canRain = (r<=0 && !g.paused && !g.gameOver);
      const canRein = (e<=0 && !g.paused && !g.gameOver);

      this.btnRain.disabled = !canRain;
      this.btnRein.disabled = !canRein;

      this.btnRain.textContent = canRain ? (g.castMode==="rain" ? "‚òÑÔ∏è Rain (Click map)" : "‚òÑÔ∏è Rain") : `‚òÑÔ∏è Rain (${Math.ceil(r)}s)`;
      this.btnRein.textContent = canRein ? (g.castMode==="rein" ? "ü™ñ Reinforce (Click map)" : "ü™ñ Reinforce") : `ü™ñ Rein (${Math.ceil(e)}s)`;
    }

    _syncHeroButtons(){
      const g = this.game;
      const hero = g.hero;
      const canHero = hero && !hero.dead;
      const canSmash = canHero && hero.smashCd<=0 && !g.paused && !g.gameOver;

      this.btnHero.disabled = (!hero || g.gameOver);
      this.btnHero.textContent = hero && hero.selected ? "ü¶∏ Hero ‚úì" : "ü¶∏ Hero";

      this.btnSmash.disabled = !canSmash;
      this.btnSmash.textContent = canSmash ? "üí• Smash" : `üí• Smash (${Math.ceil(hero ? hero.smashCd : 0)}s)`;

      if (this.heroPanel.style.display === "block") this._syncHeroPanel();
    }

    _syncHeroPanel(){
      const g = this.game;
      const h = g.hero;
      if (!h){ this.hideHeroPanel(); return; }
      this.hpTitle.textContent = `ü¶∏ ${h.name}`;
      this.hpSub.textContent = h.dead ? `ƒêang h·ªìi sinh... (${Math.ceil(h.respawnT)}s)` : "Click map ƒë·ªÉ di chuy·ªÉn (khi hero ƒëang ch·ªçn)";
      const hpPct = Math.floor((h.hp/h.maxHp)*100);
      this.hpStats.innerHTML = `
        <div>HP: <b>${Math.floor(h.hp)}/${h.maxHp}</b></div><div>HP%: <b>${hpPct}%</b></div>
        <div>Dmg: <b>${h.dmg}</b></div><div>Rate: <b>${h.rate.toFixed(2)}s</b></div>
        <div>BlockR: <b>${h.blockR}</b></div><div>Smash CD: <b>${Math.ceil(h.smashCd)}s</b></div>
      `;
      this.btnHpSmash.disabled = (h.dead || h.smashCd>0 || g.paused || g.gameOver);
      this.btnHpSmash.textContent = (h.dead ? "Smash (dead)" : (h.smashCd>0 ? `Smash (${Math.ceil(h.smashCd)}s)` : "Smash (Q)"));
    }

    _syncPanels(){
      const g = this.game;

      if (this.buildPanel.style.display === "block"){
        const pad = g.selectedPad;
        const order = ["archer","mage","barracks","artillery"];
        const cards = this.buildGrid.querySelectorAll(".card");
        cards.forEach((card,i)=>{
          const key = order[i];
          const cost = TOWER_DEFS[key].levels[0].build;
          const btn = card.querySelector("button");
          const ok = pad && !pad.tower && g.gold >= cost && !g.paused && !g.gameOver;
          btn.disabled = !ok;
        });
      }

      if (this.towerPanel.style.display === "block"){
        const t = g.selectedTower;
        if (!t){ this.hideTowerPanel(); return; }
        const canUp = t.canUpgrade();
        const upCost = t.upgradeCost();
        this.btnUpgrade.disabled = (!canUp || g.gold < upCost || g.paused || g.gameOver);
        this.btnUpgrade.textContent = canUp ? `Upgrade (${upCost})` : "Max";
        this.btnSell.disabled = (g.paused || g.gameOver);
        this.btnSell.textContent = `Sell (+${Math.floor(t.totalCost()*SELL_REFUND)})`;

        if (t.type === "barracks"){
          this.tpExtra.style.display = "flex";
          this.btnRally.disabled = (g.paused || g.gameOver);
          this.btnCancelRally.disabled = (!g.rallyMode);
        } else {
          this.tpExtra.style.display = "none";
        }
      }
    }

    showBuildPanel(screenX, screenY){
      this.hideTowerPanel();
      this.hideHeroPanel();
      const p = this.buildPanel;
      p.style.display = "block";
      this._placePanel(p, screenX, screenY);
    }

    showTowerPanel(screenX, screenY, tower){
      this.hideBuildPanel();
      this.hideHeroPanel();
      const p = this.towerPanel;
      this.tpTitle.textContent = `${tower.def.icon} ${tower.def.name}`;
      this.tpSub.textContent   = `Level ${tower.level}`;
      this.tpStats.innerHTML = this._towerStatsHTML(tower);
      p.style.display = "block";
      this._placePanel(p, screenX, screenY);
    }

    showHeroPanel(screenX, screenY){
      this.hideBuildPanel();
      this.hideTowerPanel();
      const p = this.heroPanel;
      p.style.display = "block";
      this._placePanel(p, screenX, screenY);
      this._syncHeroPanel();
    }

    _towerStatsHTML(tower){
      const ld = tower.levelDef();
      const type = tower.type;
      const dmg = (type==="barracks") ? ld.sDmg : ld.dmg;
      const range = (type==="barracks") ? ld.blockR : ld.range;
      const rate  = (type==="barracks") ? ld.sRate : ld.rate;
      const extra = (type==="barracks") ? `Soldiers: ${ld.soldiers}` :
                    (type==="artillery") ? `AoE: ${ld.blastR}` :
                    (type==="archer") ? `Crit: ${Math.round((ld.crit||0)*100)}%` :
                    (type==="mage") ? `Pierce: Armor` : "";
      const lines = [
        `Damage: <b>${Math.round(dmg)}</b>`,
        `Range: <b>${Math.round(range)}</b>`,
        `Rate: <b>${rate.toFixed(2)}s</b>`,
        extra ? `Special: <b>${extra}</b>` : `Type: <b>${tower.def.dmgType}</b>`
      ];
      return `
        <div>${lines[0]}</div><div>${lines[1]}</div>
        <div>${lines[2]}</div><div>${lines[3]}</div>
      `;
    }

    hideBuildPanel(){ this.buildPanel.style.display = "none"; }
    hideTowerPanel(){ this.towerPanel.style.display = "none"; }
    hideHeroPanel(){ this.heroPanel.style.display = "none"; }

    _placePanel(panel, x, y){
      const pad = 10;
      const rect = panel.getBoundingClientRect();
      let px = x + pad;
      let py = y + pad;
      if (px + rect.width > innerWidth - 10) px = innerWidth - rect.width - 10;
      if (py + rect.height > innerHeight - 10) py = innerHeight - rect.height - 10;
      panel.style.left = px + "px";
      panel.style.top  = py + "px";
    }

    showOverlay(title, desc){
      this.ovTitle.textContent = title;
      this.ovDesc.textContent = desc;
      this.overlay.style.display = "flex";
    }
    hideOverlay(){ this.overlay.style.display = "none"; }

    hideAllPanels(){
      this.hideBuildPanel();
      this.hideTowerPanel();
      this.hideHeroPanel();
    }
  }

  /* =========================
     Game
  ========================= */
  class Game {
    constructor(canvas){
      this.c = canvas;
      this.ctx = canvas.getContext("2d", {alpha:true});
      this.map = new GameMap();
      this.sfx = new SFX();
      this.ui = new UI(this);

      this.view = { scale:1, offX:0, offY:0, cssW:0, cssH:0 };

      // Easier start + fun extras
      this.gold = 340;
      this.lives = 25;

      this.enemies = [];
      this.towers = [];
      this.projectiles = [];
      this.soldiers = [];
      this.reinforcements = [];

      this.floaters = [];
      this.effects = [];      // meteors
      this.particles = [];    // tiny spark particles
      this.banners = [];      // funny announcements
      this.confetti = [];     // victory confetti

      this.selectedPad = null;
      this.selectedTower = null;

      this.waveManager = new WaveManager(this);
      this.paused = false;
      this.timeScale = 1;
      this.gameOver = false;

      this.rallyMode = false;
      this.castMode = null; // "rain" | "rein" | null

      this.skills = {
        rain: { cd: 0, cdMax: SKILLS.rain.cdMax },
        rein: { cd: 0, cdMax: SKILLS.rein.cdMax }
      };

      // Hero
      this.hero = new Hero(470, 470);

      // Treasure
      this.chest = null;
      this.chestSpawnT = 10.0 + Math.random()*8;

      // Cheats
      this.keyBuf = "";
      this.konami = [];
      this._konamiSeq = ["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","b","a"];

      this.shakeT = 0;
      this.shakeMag = 0;

      this.mouse = {x:0,y:0, wx:0, wy:0, down:false};
      this._bindEvents();

      this.waveManager.reset();
      this._resize();
      window.addEventListener("resize", () => this._resize());
      this.lastT = now();

      this.banner("Ch√†o m·ª´ng ƒë·∫øn v·ªõi 'KR-ish' üòÑ", "#a9b7c6", 2.2);
      this.hero.say("Xin ch√†o!", 1.4);

      requestAnimationFrame((t)=>this._loop(t));
    }

    reset(){
      this.gold = 340;
      this.lives = 25;
      this.enemies.length = 0;
      this.projectiles.length = 0;
      this.soldiers.length = 0;
      this.reinforcements.length = 0;
      this.floaters.length = 0;
      this.effects.length = 0;
      this.particles.length = 0;
      this.banners.length = 0;
      this.confetti.length = 0;

      this.skills.rain.cd = 0;
      this.skills.rein.cd = 0;

      for (const p of MAP.pads) p.tower = null;
      this.towers.length = 0;

      this.selectedPad = null;
      this.selectedTower = null;

      this.waveManager.reset();
      this.paused = false;
      this.timeScale = 1;
      this.gameOver = false;
      this.rallyMode = false;
      this.castMode = null;
      this.ui.hideAllPanels();
      this.ui.hideOverlay();

      this.hero = new Hero(470, 470);
      this.chest = null;
      this.chestSpawnT = 10.0 + Math.random()*8;

      this.banner("Restart! Ch∆°i l·∫°i cho vui üòÑ", "#a9b7c6", 1.8);
    }

    getAllFighters(){
      return [...this.soldiers, ...this.reinforcements, this.hero];
    }

    banner(text, color="#e8f1ff", dur=2.2){
      this.banners.push({text, color, t:0, dur});
      if (this.banners.length > 4) this.banners.shift();
    }

    spawnParticles(x,y,n,color){
      for (let i=0;i<n;i++){
        const a = Math.random()*TAU;
        const sp = 30 + Math.random()*130;
        this.particles.push({
          x, y,
          vx: Math.cos(a)*sp,
          vy: Math.sin(a)*sp - 40,
          t:0,
          dur: 0.35 + Math.random()*0.45,
          r: 1.2 + Math.random()*2.2,
          color
        });
      }
    }

    togglePause(){
      if (this.gameOver) return;
      this.paused = !this.paused;
      this.exitRallyMode();
      this.exitCastMode();
    }
    toggleSpeed(){
      if (this.gameOver) return;
      this.timeScale = (this.timeScale === 1) ? 2 : 1;
    }

    spawnEnemy(type){
      const e = new Enemy(type, this.map, this.waveManager.waveIndex);
      e.dist = 0;
      const p = this.map.posAlongPath(0);
      e.x = p.x + (Math.random()*6-3);
      e.y = p.y + (Math.random()*6-3);
      this.enemies.push(e);

      if (type === "boss") this.banner("Boss: 'xin ch√†o, ta l√† B... (b·ª±) üòà'", "#ff5a6a", 2.2);
    }

    explode(x,y,radius, dmg, dmgType, extra={}){
      const R2 = radius*radius;
      const hitFlying = !!extra.hitFlying;
      const stun = extra.stun || 0;
      const slowMul = extra.slowMul || 1.0;
      const slowDur = extra.slowDur || 0;

      for (const e of this.enemies){
        if (e.dead) continue;
        if (!hitFlying && e.flying) continue;
        const d2 = dist2(x,y, e.x, e.y - (e.flying ? 10 : 0));
        if (d2 <= R2){
          const d = Math.sqrt(d2);
          const mult = 1 - (d / radius) * 0.45;
          e.takeDamage(dmg * mult, dmgType);
          if (slowDur > 0) e.applySlow(slowMul, slowDur);
          if (stun > 0) e.applyStun(stun);
        }
      }
      this._addExplosionFX(x,y,radius, extra.fire ? "fire" : "boom");
    }

    _addExplosionFX(x,y,r, kind="boom"){
      this.floaters.push({x,y, vx:0, vy:-25, t:0, dur:0.55, txt:"", col:"", size:0, ring:true, r, kind});
    }

    findEnemyNear(x,y, radius){
      const R2 = radius*radius;
      let best = null, bestD2 = 1e9;
      for (const e of this.enemies){
        if (e.dead) continue;
        const d2 = dist2(x,y, e.x, e.y - (e.flying ? 10 : 0));
        if (d2 <= R2 && d2 < bestD2){ bestD2 = d2; best = e; }
      }
      return best;
    }

    floatText(x,y, txt, col="#e8f1ff", dur=0.9){
      this.floaters.push({x,y, vx:(Math.random()*20-10), vy:-32, t:0, dur, txt, col, size:13+Math.random()*2, ring:false});
    }

    onVictory(){
      if (this.gameOver) return;
      this.gameOver = true;
      this.ui.showOverlay("Victory!", "B·∫°n ƒë√£ th·ªß th√†nh c√¥ng t·∫•t c·∫£ 12 wave. Nh·∫•n Restart ƒë·ªÉ ch∆°i l·∫°i.\n(Psst‚Ä¶ th·ª≠ g√µ 'BANANA' xem üòÑ)");
      this.sfx.win();
      this.banner("VICTORY! üéâ", "#62d26f", 2.2);

      // confetti
      this.confetti.length = 0;
      for (let i=0;i<140;i++){
        this.confetti.push({
          x: Math.random()*this.view.cssW,
          y: -20 - Math.random()*this.view.cssH*0.2,
          vx: (Math.random()*2-1)*80,
          vy: 60 + Math.random()*160,
          a: Math.random()*TAU,
          va:(Math.random()*2-1)*6,
          w: 6 + Math.random()*8,
          h: 6 + Math.random()*10,
          t:0,
          dur: 3.0 + Math.random()*2.0,
          col: `hsla(${Math.floor(Math.random()*360)}, 90%, 65%, 0.85)`
        });
      }
    }
    onDefeat(){
      if (this.gameOver) return;
      this.gameOver = true;
      this.ui.showOverlay("Defeat!", "CƒÉn c·ª© ƒë√£ th·∫•t th·ªß (Lives = 0). Nh·∫•n Restart ƒë·ªÉ th·ª≠ l·∫°i.\nTip: d√πng Rain/Rein/Smash ƒë√∫ng l√∫c s·∫Ω r·∫•t 'ngon' üòÑ");
      this.sfx.lose();
      this.banner("DEFEAT‚Ä¶ üò≠", "#ff5a6a", 2.2);
    }

    /* ========== Skills ========== */
    tryEnterCastMode(key){
      if (this.paused || this.gameOver) return;
      if (key === "rain"){
        if (this.skills.rain.cd > 0) return;
        this.castMode = (this.castMode === "rain") ? null : "rain";
        this.exitRallyMode();
        this.ui.hideAllPanels();
        if (this.castMode) this.banner("Ch·ªçn ƒëi·ªÉm th·∫£ Rain! ‚òÑÔ∏è", "#ffcc4d", 1.4);
      } else if (key === "rein"){
        if (this.skills.rein.cd > 0) return;
        this.castMode = (this.castMode === "rein") ? null : "rein";
        this.exitRallyMode();
        this.ui.hideAllPanels();
        if (this.castMode) this.banner("Ch·ªçn ƒëi·ªÉm g·ªçi vi·ªán tr·ª£! ü™ñ", "#62d26f", 1.4);
      }
    }
    exitCastMode(){ this.castMode = null; }

    castRain(x,y){
      const s = SKILLS.rain;
      this.skills.rain.cd = s.cdMax;
      this.exitCastMode();

      for (let i=0;i<s.meteors;i++){
        const ang = Math.random()*TAU;
        const rad = Math.random()*s.spread;
        const px = x + Math.cos(ang)*rad;
        const py = y + Math.sin(ang)*rad;
        const delay = i * 0.10 + Math.random()*0.08;
        this.effects.push({ kind:"meteor", t:0, delay, fromX:px + (Math.random()*40-20), fromY: py - (170 + Math.random()*80), toX:px, toY:py, hit:false });
      }
      this.floatText(x, y-40, "RAIN OF FIRE!", "#ffcc4d", 0.9);
      this.sfx.meteor();
      this.banner("‚òÑÔ∏è B√ôM B√ôM B√ôM!", "#ffcc4d", 1.3);
      if (Math.random()<0.35) this.hero.say("N∆∞·ªõng h·∫øt!", 1.2);
    }

    castRein(x,y){
      const s = SKILLS.rein;
      this.skills.rein.cd = s.cdMax;
      this.exitCastMode();

      const def = { duration: s.duration, hp: s.hp, dmg: s.dmg, rate: s.rate, spd: s.spd, blockR: s.blockR };
      for (let i=0;i<s.units;i++){
        this.reinforcements.push(new Reinforcement(x,y, i, def));
      }
      this.floatText(x, y-34, "REINFORCEMENTS!", "#62d26f", 0.85);
      this.sfx.beep(680,0.08,"triangle",0.20);
      if (Math.random()<0.35) this.hero.say("Anh em ∆°i!", 1.2);
    }

    /* ========== Hero controls ========== */
    toggleHeroSelect(){
      if (!this.hero) return;
      if (this.hero.selected){
        this.deselectHero();
      } else {
        this.selectHero(this.mouse.x || (this.view.cssW*0.5), this.mouse.y || (this.view.cssH*0.5));
      }
    }
    selectHero(sx, sy){
      this.selectedPad = null;
      this.selectedTower = null;
      for (const t of this.towers) t.selected = false;
      this.hero.selected = true;
      this.exitRallyMode();
      this.exitCastMode();
      this.ui.showHeroPanel(sx, sy);
      this.sfx.hero();
      if (Math.random()<0.5) this.hero.say("Ra l·ªánh ƒëi!", 1.2);
    }
    deselectHero(){
      this.hero.selected = false;
      this.ui.hideHeroPanel();
    }
    tryHeroSmash(){
      if (this.paused || this.gameOver) return;
      if (!this.hero || this.hero.dead) return;
      const ok = this.hero.castSmash(this);
      if (ok) this.sfx.beep(220,0.08,"sawtooth",0.22);
    }

    /* ========== Build/Upgrade/Sell ========== */
    tryBuildOnSelectedPad(typeKey){
      const pad = this.selectedPad;
      if (!pad || pad.tower) return;
      const def = TOWER_DEFS[typeKey];
      const cost = def.levels[0].build;
      if (this.gold < cost || this.paused || this.gameOver) return;

      this.gold -= cost;
      const t = new Tower(typeKey, pad.x, pad.y, pad.id);
      t.spent += cost;
      pad.tower = t;
      this.towers.push(t);

      this.selectTower(t, this.mouse.x, this.mouse.y);
      this.ui.hideBuildPanel();
      this.sfx.build();

      if (Math.random() < 0.55) this.banner(JOKES[Math.floor(Math.random()*JOKES.length)], "#a9b7c6", 1.8);
    }

    tryUpgradeSelected(){
      const t = this.selectedTower;
      if (!t || !t.canUpgrade() || this.paused || this.gameOver) return;
      const cost = t.upgradeCost();
      if (this.gold < cost) return;
      this.gold -= cost;
      t.spent += cost;
      t.upgrade();
      this.sfx.upgrade();
      this.banner("Upgrade! üìà", "#62d26f", 1.2);
      if (Math.random() < 0.25) this.hero.say("X·ªãn!", 0.9);
    }

    trySellSelected(){
      const t = this.selectedTower;
      if (!t || this.paused || this.gameOver) return;
      const refund = Math.floor(t.totalCost() * SELL_REFUND);
      this.gold += refund;

      const pad = MAP.pads.find(p=>p.id === t.padId);
      if (pad) pad.tower = null;

      if (t.type === "barracks" && t._soldiers){
        for (const s of t._soldiers){ s.dead = true; s.respawnT = 999; }
        this.soldiers = this.soldiers.filter(s=>s.owner !== t);
      }

      this.towers = this.towers.filter(x=>x !== t);

      this.selectedTower = null;
      this.selectedPad = null;
      this.ui.hideAllPanels();
      this.exitRallyMode();
      this.exitCastMode();
      this.sfx.sell();
      this.banner("Sold! üí∏", "#ffcc4d", 1.2);
    }

    /* ========== Selection / Rally ========== */
    selectPad(pad, sx, sy){
      this.selectedPad = pad;
      this.selectedTower = null;
      for (const t of this.towers) t.selected = false;
      this.deselectHero();
      this.exitRallyMode();
      this.exitCastMode();

      if (pad && !pad.tower) this.ui.showBuildPanel(sx, sy);
      else if (pad && pad.tower) this.selectTower(pad.tower, sx, sy);
    }

    selectTower(tower, sx, sy){
      this.selectedTower = tower;
      this.selectedPad = null;
      for (const t of this.towers) t.selected = (t === tower);
      this.deselectHero();
      this.ui.showTowerPanel(sx, sy, tower);
      this.exitRallyMode(false);
      this.exitCastMode();
    }

    clearSelection(){
      this.selectedPad = null;
      this.selectedTower = null;
      for (const t of this.towers) t.selected = false;
      this.ui.hideAllPanels();
      this.exitRallyMode();
      this.exitCastMode();
      this.deselectHero();
    }

    enterRallyMode(){
      const t = this.selectedTower;
      if (!t || t.type !== "barracks") return;
      this.rallyMode = true;
      this.exitCastMode();
      this.banner("Ch·ªçn ƒëi·ªÉm Rally cho Barracks!", "#55b6ff", 1.4);
    }

    exitRallyMode(){ this.rallyMode = false; }

    /* ========== Treasure ========== */
    _spawnChest(){
      // Find a pleasant spot (not too close to path/pads/end)
      for (let tries=0; tries<40; tries++){
        const x = 40 + Math.random()*(MAP.w-80);
        const y = 40 + Math.random()*(MAP.h-80);
        const dPath = this.map.distanceToPath(x,y);
        if (dPath < MAP.pathWidth*0.75) continue;

        let ok = true;
        for (const p of MAP.pads){
          if (Math.hypot(x-p.x,y-p.y) < 60){ ok=false; break; }
        }
        if (!ok) continue;
        if (Math.hypot(x-MAP.end.x, y-MAP.end.y) < 120) continue;
        if (Math.hypot(x-MAP.start.x, y-MAP.start.y) < 120) continue;

        this.chest = { x, y, r: 16, t:0, ttl: 10.5, gold: rndi(24, 40) };
        this.banner("‚ú® R∆∞∆°ng xu·∫•t hi·ªán! Click ƒë·ªÉ nh·∫∑t v√†ng!", "#ffcc4d", 2.2);
        this.sfx.sparkle();
        return;
      }
    }

    tryCollectChest(wx, wy){
      if (!this.chest) return false;
      const d2 = dist2(wx,wy,this.chest.x,this.chest.y);
      if (d2 <= (this.chest.r+6)*(this.chest.r+6)){
        const g = this.chest.gold;
        this.gold += g;
        this.floatText(this.chest.x, this.chest.y-18, `+${g} gold`, "#ffcc4d", 0.95);
        this.spawnParticles(this.chest.x, this.chest.y, 28, "rgba(255,204,77,0.22)");
        this.sfx.sparkle();
        if (Math.random()<0.5) this.hero.say("L·ª•m l·ª•m!", 1.0);
        this.chest = null;
        this.chestSpawnT = 18 + Math.random()*16;
        return true;
      }
      return false;
    }

    /* ========== Main loop ========== */
    _loop(t){
      const dtRaw = Math.min(0.05, (t - this.lastT) / 1000);
      this.lastT = t;

      const dt = (this.paused || this.gameOver) ? 0 : dtRaw * this.timeScale;

      this.update(dt, dtRaw);
      this.render(t);
      this.ui.update();

      requestAnimationFrame((tt)=>this._loop(tt));
    }

    update(dt, dtRaw){
      // Skills cooldown tick (real-time)
      if (!this.paused && !this.gameOver){
        const prevRain = this.skills.rain.cd;
        const prevRein = this.skills.rein.cd;
        this.skills.rain.cd = Math.max(0, this.skills.rain.cd - dtRaw);
        this.skills.rein.cd = Math.max(0, this.skills.rein.cd - dtRaw);
        if (prevRain > 0 && this.skills.rain.cd === 0) this.sfx.skillReady();
        if (prevRein > 0 && this.skills.rein.cd === 0) this.sfx.skillReady();
      }

      // Banners time
      for (const b of this.banners){ b.t += dtRaw; }
      this.banners = this.banners.filter(b=>b.t < b.dur);

      // Treasure timer
      if (!this.paused && !this.gameOver){
        if (!this.chest){
          this.chestSpawnT -= dtRaw;
          if (this.chestSpawnT <= 0){
            this._spawnChest();
            this.chestSpawnT = 18 + Math.random()*16;
          }
        } else {
          this.chest.t += dtRaw;
          if (this.chest.t >= this.chest.ttl){
            this.chest = null;
            this.chestSpawnT = 16 + Math.random()*18;
          }
        }
      }

      // Confetti always animates
      for (const c of this.confetti){
        c.t += dtRaw;
        c.x += c.vx*dtRaw;
        c.y += c.vy*dtRaw;
        c.a += c.va*dtRaw;
        c.vx *= (1 - 0.03*dtRaw);
        c.vy *= (1 - 0.02*dtRaw);
        c.vy += 120*dtRaw;
        if (c.y > this.view.cssH + 40) c.y = -30;
        if (c.x < -50) c.x = this.view.cssW + 50;
        if (c.x > this.view.cssW + 50) c.x = -50;
      }
      this.confetti = this.confetti.filter(c => c.t < c.dur);

      // Particles
      for (const p of this.particles){
        p.t += dtRaw;
        p.x += p.vx*dtRaw;
        p.y += p.vy*dtRaw;
        p.vx *= (1 - 0.10*dtRaw);
        p.vy *= (1 - 0.10*dtRaw);
        p.vy += 220*dtRaw;
      }
      this.particles = this.particles.filter(p => p.t < p.dur);

      // Hero (updates even if paused? keep paused freeze movement, but cooldown uses dtRaw already)
      if (!this.gameOver){
        if (!this.paused) this.hero.update(dt, dtRaw, this);
        else this.hero.update(0, dtRaw, this); // bubble/cd keep ticking
      }

      if (!this.paused && !this.gameOver){
        this.waveManager.update(dt);
        for (const tw of this.towers) tw.update(dt, this);
        for (const e of this.enemies) e.update(dt, this);
        for (const p of this.projectiles) p.update(dt, this);
        for (const s of this.soldiers) s.update(dt, this);
        for (const r of this.reinforcements) r.update(dt, this);
      }

      // effects (meteors)
      for (const fx of this.effects){
        fx.t += dtRaw;
        if (fx.kind === "meteor" && !fx.hit && fx.t >= fx.delay){
          const fallT = clamp((fx.t - fx.delay) / 0.28, 0, 1);
          if (fallT >= 1){
            fx.hit = true;
            const s = SKILLS.rain;
            this.explode(fx.toX, fx.toY, s.radius, s.damage, s.dmgType, { hitFlying:true, stun: s.stun, fire:true });
            this.sfx.meteor();
            this.floatText(fx.toX, fx.toY-22, `${Math.round(s.damage)}`, "#ffcc4d", 0.55);
            this.spawnParticles(fx.toX, fx.toY, 18, "rgba(255,90,106,0.18)");
            if (Math.random()<0.25) this.shakeT = Math.max(this.shakeT, 0.08), this.shakeMag = Math.max(this.shakeMag, 3);
          }
        }
      }
      this.effects = this.effects.filter(fx => !(fx.kind==="meteor" && fx.hit && fx.t > fx.delay + 0.60));

      // cleanup + rewards + lives
      if (!this.paused && !this.gameOver){
        let lifeLost = 0;
        for (const e of this.enemies){
          if (e.reachedEnd) lifeLost += e.dmgToLives || 1;
          if (e.dead && !e.reachedEnd){
            this.gold += e.reward;
            this.floatText(e.x, e.y - (e.flying ? 20 : 10), `+${e.reward}`, "#ffcc4d", 0.75);
            if (Math.random()<0.20) this.spawnParticles(e.x,e.y,10,"rgba(255,255,255,0.14)");
          }
          if (e.dead){
            if (e.engagers && e.engagers.length){
              for (const s of e.engagers){
                if (s && s.target === e) s.target = null;
              }
              e.engagers.length = 0;
            }
          }
        }
        if (lifeLost > 0){
          this.lives -= lifeLost;
          this.floatText(MAP.end.x, MAP.end.y-55, `-${lifeLost} lives`, "#ff5a6a", 0.9);
          this.sfx.hurt();
          if (this.lives <= 0){
            this.lives = 0;
            this.onDefeat();
          }
        }

        this.enemies = this.enemies.filter(e => !e.dead);
        this.projectiles = this.projectiles.filter(p => !p.dead);
        this.reinforcements = this.reinforcements.filter(r => !r.dead);
      }

      // floaters drift
      for (const f of this.floaters){
        f.t += dtRaw;
        f.x += f.vx * dtRaw;
        f.y += f.vy * dtRaw;
      }
      this.floaters = this.floaters.filter(f => f.t < f.dur);

      // shake
      if (this.shakeT > 0){
        this.shakeT -= dtRaw;
        if (this.shakeT <= 0){ this.shakeT = 0; this.shakeMag = 0; }
      }
    }

    render(time){
      const ctx = this.ctx;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0, this.view.cssW, this.view.cssH);

      let shakeX = 0, shakeY = 0;
      if (this.shakeT > 0){
        const k = (this.shakeT / 0.22);
        const mag = this.shakeMag * k;
        shakeX = (Math.random()*2-1) * mag;
        shakeY = (Math.random()*2-1) * mag;
      }
      ctx.translate(shakeX, shakeY);

      this.map.render(ctx, this.view, time);

      ctx.save();
      ctx.translate(this.view.offX, this.view.offY);
      ctx.scale(this.view.scale, this.view.scale);

      // selected tower range
      if (this.selectedTower){
        this.selectedTower.renderRange(ctx);
      }
      // selected hero range
      if (this.hero && this.hero.selected){
        this.hero.renderRange(ctx);
      }

      // rally mode indicator
      if (this.rallyMode && this.selectedTower && this.selectedTower.type === "barracks"){
        const mx = this.mouse.wx, my = this.mouse.wy;
        ctx.strokeStyle = "rgba(85,182,255,0.55)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(mx,my, 12, 0, TAU); ctx.stroke();
        ctx.fillStyle = "rgba(85,182,255,0.12)";
        ctx.beginPath(); ctx.arc(mx,my, 26, 0, TAU); ctx.fill();
        ctx.fillStyle = "rgba(232,241,255,0.85)";
        ctx.font = "900 12px system-ui,Segoe UI,Arial";
        ctx.textAlign="center"; ctx.textBaseline="bottom";
        ctx.fillText("Click to set Rally", mx, my-18);
      }

      // cast mode indicator
      if (this.castMode){
        const mx = this.mouse.wx, my = this.mouse.wy;
        if (this.castMode === "rain"){
          const s = SKILLS.rain;
          ctx.fillStyle = "rgba(255,204,77,0.10)";
          ctx.strokeStyle = "rgba(255,204,77,0.30)";
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(mx,my, s.radius, 0, TAU); ctx.fill(); ctx.stroke();
          ctx.fillStyle = "rgba(232,241,255,0.85)";
          ctx.font = "900 12px system-ui,Segoe UI,Arial";
          ctx.textAlign="center"; ctx.textBaseline="bottom";
          ctx.fillText("‚òÑÔ∏è Rain of Fire: click to cast", mx, my - s.radius - 8);
        } else if (this.castMode === "rein"){
          const s = SKILLS.rein;
          ctx.fillStyle = "rgba(98,210,111,0.10)";
          ctx.strokeStyle = "rgba(98,210,111,0.30)";
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(mx,my, s.blockR, 0, TAU); ctx.fill(); ctx.stroke();
          ctx.fillStyle = "rgba(232,241,255,0.85)";
          ctx.font = "900 12px system-ui,Segoe UI,Arial";
          ctx.textAlign="center"; ctx.textBaseline="bottom";
          ctx.fillText("ü™ñ Reinforcements: click to deploy", mx, my - s.blockR - 8);
        }
      }

      // meteors visual
      for (const fx of this.effects){
        if (fx.kind !== "meteor") continue;
        const fallT = clamp((fx.t - fx.delay) / 0.28, 0, 1);
        if (fallT <= 0) continue;
        const x = lerp(fx.fromX, fx.toX, fallT);
        const y = lerp(fx.fromY, fx.toY, fallT);
        const tailX = lerp(fx.fromX, fx.toX, clamp(fallT-0.18,0,1));
        const tailY = lerp(fx.fromY, fx.toY, clamp(fallT-0.18,0,1));
        ctx.strokeStyle = "rgba(255,204,77,0.55)";
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(tailX,tailY); ctx.lineTo(x,y); ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.beginPath(); ctx.arc(x,y, 3.5, 0, TAU); ctx.fill();
        if (!fx.hit){
          ctx.strokeStyle = "rgba(255,204,77,0.22)";
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(fx.toX, fx.toY, 10 + 10*Math.sin(fx.t*18), 0, TAU); ctx.stroke();
        }
      }

      // treasure chest
      if (this.chest){
        const c = this.chest;
        const pulse = 0.45 + 0.55*Math.sin((time*0.003) + c.x*0.01);
        // glow
        ctx.fillStyle = `rgba(255,204,77,${0.10 + 0.08*pulse})`;
        ctx.beginPath(); ctx.arc(c.x,c.y, 22, 0, TAU); ctx.fill();

        // shadow
        ctx.fillStyle = "rgba(0,0,0,0.28)";
        ctx.beginPath(); ctx.ellipse(c.x+2, c.y+7, 18, 10, 0, 0, TAU); ctx.fill();

        // chest body
        ctx.fillStyle = "#7b5a38";
        ctx.beginPath(); ctx.roundRect(c.x-14, c.y-10, 28, 22, 6); ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.lineWidth = 2; ctx.stroke();

        ctx.fillStyle = "#ffcc4d";
        ctx.beginPath(); ctx.roundRect(c.x-4, c.y-4, 8, 10, 4); ctx.fill();

        // sparkle stars
        ctx.strokeStyle = `rgba(255,255,255,${0.22 + 0.20*pulse})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(c.x+18, c.y-18); ctx.lineTo(c.x+18, c.y-10);
        ctx.moveTo(c.x+14, c.y-14); ctx.lineTo(c.x+22, c.y-14);
        ctx.stroke();

        // ttl ring
        const lp = clamp(1 - (c.t/c.ttl), 0, 1);
        ctx.strokeStyle = `rgba(255,204,77,${0.20 + 0.22*lp})`;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(c.x,c.y, 26, -Math.PI/2, -Math.PI/2 + TAU*lp); ctx.stroke();
      }

      // towers
      for (const t of this.towers) t.render(ctx);

      // enemies (depth by y)
      const sortedEnemies = this.enemies.slice().sort((a,b)=> (a.y - b.y));
      for (const e of sortedEnemies) e.render(ctx);

      // soldiers + reinforcements + hero (depth by y)
      const allFriend = [...this.soldiers, ...this.reinforcements, this.hero].slice().sort((a,b)=>a.y-b.y);
      for (const s of allFriend) s.render(ctx);

      // projectiles
      for (const p of this.projectiles) p.render(ctx);

      // floaters / explosion rings
      for (const f of this.floaters){
        const k = clamp(f.t / f.dur, 0, 1);
        const a = 1 - k;
        if (f.ring){
          const rr = f.r * (0.55 + 0.75*k);
          const colA = (f.kind==="fire") ? `rgba(255,90,106,${0.10*a})` : `rgba(255,204,77,${0.18*a})`;
          ctx.strokeStyle = colA;
          ctx.lineWidth = 4;
          ctx.beginPath(); ctx.arc(f.x,f.y, rr, 0, TAU); ctx.stroke();
          ctx.strokeStyle = `rgba(255,255,255,${0.08*a})`;
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(f.x,f.y, rr*0.72, 0, TAU); ctx.stroke();
        } else if (f.txt){
          ctx.save();
          ctx.globalAlpha = a;
          ctx.fillStyle = f.col;
          ctx.font = `900 ${Math.floor(f.size)}px system-ui,Segoe UI,Arial`;
          ctx.textAlign="center"; ctx.textBaseline="middle";
          ctx.fillText(f.txt, f.x, f.y);
          ctx.restore();
        }
      }

      // particles
      for (const p of this.particles){
        const k = clamp(p.t / p.dur, 0, 1);
        const a = 1 - k;
        ctx.fillStyle = p.color.replace(/[\d.]+\)\s*$/, `${0.12 + 0.55*a})`).replace("rgb","rgba");
        // fallback if input is already rgba(...)
        ctx.fillStyle = p.color.includes("rgba") ? p.color.replace(/[\d.]+\)\s*$/, `${0.12 + 0.55*a})`) : p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, TAU);
        ctx.fill();
      }

      ctx.restore();

      this._drawFrame(ctx);

      // Day/Night tint (very subtle)
      const phase = (time * 0.00002) % 1;
      const night = 0.06 + 0.10 * (0.5 - 0.5*Math.cos(phase*TAU)); // 0.06..0.16
      ctx.save();
      ctx.fillStyle = `rgba(0,0,25,${night})`;
      ctx.fillRect(0,0,this.view.cssW,this.view.cssH);
      ctx.restore();

      // Banners (screen space)
      this._drawBanners(ctx);

      // Confetti (screen space)
      this._drawConfetti(ctx);
    }

    _drawBanners(ctx){
      if (!this.banners.length) return;
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.font = "900 14px system-ui,Segoe UI,Arial";

      let y = 76;
      for (const b of this.banners){
        const k = clamp(b.t / b.dur, 0, 1);
        const a = (k < 0.10) ? (k/0.10) : (k > 0.88 ? (1 - (k-0.88)/0.12) : 1);
        ctx.globalAlpha = a;

        const w = ctx.measureText(b.text).width + 22;
        const x = this.view.cssW * 0.5;
        const px = x - w/2;
        const py = y;

        ctx.fillStyle = "rgba(10,14,20,0.78)";
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.roundRect(px, py, w, 28, 12);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = b.color;
        ctx.fillText(b.text, x, py + 7);

        y += 34;
      }

      ctx.restore();
    }

    _drawConfetti(ctx){
      if (!this.confetti.length) return;
      ctx.save();
      for (const c of this.confetti){
        const k = clamp(c.t / c.dur, 0, 1);
        const a = 1 - k;
        ctx.globalAlpha = a;
        ctx.translate(c.x, c.y);
        ctx.rotate(c.a);
        ctx.fillStyle = c.col;
        ctx.fillRect(-c.w/2, -c.h/2, c.w, c.h);
        ctx.setTransform(1,0,0,1,0,0);
      }
      ctx.restore();
    }

    _drawFrame(ctx){
      const v = this.view;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 2;
      ctx.strokeRect(v.offX+1, v.offY+1, v.scale*MAP.w-2, v.scale*MAP.h-2);

      ctx.fillStyle = "rgba(0,0,0,0.30)";
      ctx.fillRect(0,0, v.cssW, v.offY);
      ctx.fillRect(0, v.offY + v.scale*MAP.h, v.cssW, v.cssH);
      ctx.fillRect(0, v.offY, v.offX, v.scale*MAP.h);
      ctx.fillRect(v.offX + v.scale*MAP.w, v.offY, v.cssW, v.scale*MAP.h);
      ctx.restore();
    }

    /* ========== Input ========== */
    _bindEvents(){
      const rectOf = () => this.c.getBoundingClientRect();
      const updateMouse = (e) => {
        const rect = rectOf();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        this.mouse.x = x; this.mouse.y = y;
        const wx = (x - this.view.offX) / this.view.scale;
        const wy = (y - this.view.offY) / this.view.scale;
        this.mouse.wx = clamp(wx, 0, MAP.w);
        this.mouse.wy = clamp(wy, 0, MAP.h);
      };

      this.c.addEventListener("pointerdown", (e) => {
        this.sfx.ensure();
        updateMouse(e);
        this.mouse.down = true;

        const target = e.target;
        if (target && target !== this.c) return;

        if (!this.paused && !this.gameOver){
          // Cast mode first
          if (this.castMode === "rain" && this.skills.rain.cd <= 0){
            this.castRain(this.mouse.wx, this.mouse.wy);
            return;
          }
          if (this.castMode === "rein" && this.skills.rein.cd <= 0){
            this.castRein(this.mouse.wx, this.mouse.wy);
            return;
          }

          // Rally placement
          if (this.rallyMode && this.selectedTower && this.selectedTower.type==="barracks"){
            this.selectedTower.rallyX = this.mouse.wx;
            this.selectedTower.rallyY = this.mouse.wy;
            this.rallyMode = false;
            this.sfx.beep(620,0.06,"triangle",0.22);
            this.banner("Rally set!", "#55b6ff", 1.1);
            return;
          }

          // Treasure click
          if (this.tryCollectChest(this.mouse.wx, this.mouse.wy)){
            return;
          }
        }

        // Hero click/select/move
        if (this.hero && !this.hero.dead){
          const hy = this.hero.y;
          const d2 = dist2(this.mouse.wx, this.mouse.wy, this.hero.x, hy);
          if (d2 <= 18*18){
            this.selectHero(e.clientX, e.clientY);
            return;
          }
          if (this.hero.selected){
            this.hero.setDestination(this.mouse.wx, this.mouse.wy);
            this.sfx.hero();
            if (Math.random()<0.25) this.hero.say("ƒêang t·ªõi!", 0.9);
            return;
          }
        }

        const hitPad = this._hitTestPads(this.mouse.wx, this.mouse.wy);
        if (hitPad){ this.selectPad(hitPad, e.clientX, e.clientY); return; }

        const tw = this._hitTestTowers(this.mouse.wx, this.mouse.wy);
        if (tw){ this.selectTower(tw, e.clientX, e.clientY); return; }

        this.clearSelection();
      });

      this.c.addEventListener("pointermove", (e) => updateMouse(e));
      window.addEventListener("pointerup", () => { this.mouse.down = false; });

      window.addEventListener("keydown", (e) => {
        if (e.repeat) return;

        // Konami
        this.konami.push(e.key);
        if (this.konami.length > this._konamiSeq.length) this.konami.shift();
        const match = this._konamiSeq.every((k,i)=>this.konami[i] === k);
        if (match){
          this.gold += 150;
          this.skills.rain.cd = 0;
          this.skills.rein.cd = 0;
          this.hero.smashCd = 0;
          this.banner("KONAMI! +150 gold & reset cooldowns ü§´", "#ffcc4d", 2.6);
          this.hero.say("Cheat code?! üòÑ", 1.4);
          this.spawnParticles(this.hero.x, this.hero.y, 40, "rgba(255,204,77,0.22)");
          this.sfx.sparkle();
        }

        // Text buffer cheat: BANANA
        if (e.key.length === 1){
          this.keyBuf += e.key.toUpperCase();
          if (this.keyBuf.length > 12) this.keyBuf = this.keyBuf.slice(-12);
          if (this.keyBuf.includes("BANANA")){
            this.keyBuf = "";
            const bonus = 77;
            this.gold += bonus;
            this.banner("üçå BANANA BONUS! +77 gold", "#ffcc4d", 2.2);
            this.hero.say("BANANA!", 1.2);
            this.sfx.sparkle();
          }
        }

        if (e.code === "Space"){
          e.preventDefault();
          this.sfx.ensure();
          this.togglePause();
          return;
        }

        if (e.key === "s" || e.key === "S"){
          this.sfx.ensure();
          if (this.waveManager.state === "countdown") this.waveManager.startWave(true);
          else if (this.waveManager.canStartWave()) this.waveManager.startWave(false);
          return;
        }

        if (e.key === "1") this.timeScale = 1;
        if (e.key === "2") this.timeScale = 2;

        if (e.key === "r" || e.key === "R"){
          this.sfx.ensure();
          this.tryEnterCastMode("rain");
          return;
        }
        if (e.key === "e" || e.key === "E"){
          this.sfx.ensure();
          this.tryEnterCastMode("rein");
          return;
        }
        if (e.key === "q" || e.key === "Q"){
          this.sfx.ensure();
          this.tryHeroSmash();
          return;
        }
        if (e.key === "h" || e.key === "H"){
          this.sfx.ensure();
          this.toggleHeroSelect();
          return;
        }

        if (e.key === "Escape"){
          this.exitCastMode();
          this.exitRallyMode();
          this.deselectHero();
        }
      });

      document.addEventListener("pointerdown", (e) => {
        const inside = (el) => el.style.display==="block" && el.contains(e.target);
        const isHudBtn = document.getElementById("hud").contains(e.target);
        if (inside(this.ui.buildPanel) || inside(this.ui.towerPanel) || inside(this.ui.heroPanel) || isHudBtn) return;
        if (!this.selectedTower && !this.selectedPad && !this.hero.selected){
          this.ui.hideAllPanels();
        }
      }, true);
    }

    _hitTestPads(wx, wy){
      const R = MAP.padR + 6;
      const R2 = R*R;
      let best = null;
      let bestD2 = 1e9;
      for (const p of MAP.pads){
        const d2 = dist2(wx,wy,p.x,p.y);
        if (d2 <= R2 && d2 < bestD2){ bestD2 = d2; best = p; }
      }
      return best;
    }

    _hitTestTowers(wx, wy){
      let best = null, bestD2 = 1e9;
      for (const t of this.towers){
        const d2 = dist2(wx,wy,t.x,t.y);
        if (d2 < 28*28 && d2 < bestD2){ bestD2 = d2; best = t; }
      }
      return best;
    }

    /* ========== Resize / HiDPI ========== */
    _resize(){
      const rect = this.c.getBoundingClientRect();
      const cssW = Math.max(1, Math.floor(rect.width));
      const cssH = Math.max(1, Math.floor(rect.height));
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      this.c.width  = Math.floor(cssW * dpr);
      this.c.height = Math.floor(cssH * dpr);

      this.ctx.setTransform(dpr,0,0,dpr,0,0);

      const scale = Math.min(cssW / MAP.w, cssH / MAP.h);
      const viewW = MAP.w * scale;
      const viewH = MAP.h * scale;
      const offX = Math.floor((cssW - viewW) * 0.5);
      const offY = Math.floor((cssH - viewH) * 0.5);

      this.view.cssW = cssW;
      this.view.cssH = cssH;
      this.view.scale = scale;
      this.view.offX = offX;
      this.view.offY = offY;
    }
  }

  // roundRect polyfill
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  const game = new Game(document.getElementById("c"));
  window.__TD = game;

})();
</script>

<!--
H∆Ø·ªöNG D·∫™N NHANH:
1) T·∫°o file "index.html" ‚Üí d√°n to√†n b·ªô n·ªôi dung n√†y ‚Üí l∆∞u ‚Üí m·ªü b·∫±ng Chrome/Edge (offline).
2) Click pad ƒë·ªÉ x√¢y, click th√°p ƒë·ªÉ upgrade/sell; Barracks: Rally r·ªìi click map.
3) Skills: R = Rain of Fire, E = Reinforcements (b·∫•m r·ªìi click map ƒë·ªÉ th·∫£).
4) Hero: click hero ƒë·ªÉ ch·ªçn, click map ƒë·ªÉ di chuy·ªÉn; Q = Smash; H = ch·ªçn/b·ªè ch·ªçn hero.
5) M·∫πo vui: r∆∞∆°ng v√†ng xu·∫•t hi·ªán ng·∫´u nhi√™n ‚Äî click ƒë·ªÉ nh·∫∑t; th·ª≠ g√µ "BANANA" ho·∫∑c Konami code üòÑ
-->
</body>
</html>